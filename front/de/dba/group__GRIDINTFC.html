<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FronTier++: FronTier Interface-Grid Functions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FronTier++
   </div>
   <div id="projectbrief">Softerware for front tracking method</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FronTier Interface-Grid Functions<div class="ingroups"><a class="el" href="../../d4/d6d/group__fapi.html">FronTier Function</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2bac4ec588ff38cb9ac1abba111146c9"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2bac4ec588ff38cb9ac1abba111146c9">FT_MakeGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:ga2bac4ec588ff38cb9ac1abba111146c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate interface whose topological grid is the expanded dual grid, currently with buffer of 4h for PERIODIC and SUBDOMAIN boundary, 1h for other boundaries. Install crossings of the interface and the expanded dual grid and store them in the interface table. These crossings can be used to interact with various PDE solvers.  <a href="#ga2bac4ec588ff38cb9ac1abba111146c9">More...</a><br/></td></tr>
<tr class="separator:ga2bac4ec588ff38cb9ac1abba111146c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03dfa34f5478d732b91a297188a6bfb5"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga03dfa34f5478d732b91a297188a6bfb5">FT_FreeGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:ga03dfa34f5478d732b91a297188a6bfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space of grid crossing interface made by the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2bac4ec588ff38cb9ac1abba111146c9" title="Make a duplicate interface whose topological grid is the expanded dual grid, currently with buffer of...">FT_MakeGridIntfc()</a>.  <a href="#ga03dfa34f5478d732b91a297188a6bfb5">More...</a><br/></td></tr>
<tr class="separator:ga03dfa34f5478d732b91a297188a6bfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d43787e4dee696c039d4286a904c5c"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga70d43787e4dee696c039d4286a904c5c">FT_MakeCompGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:ga70d43787e4dee696c039d4286a904c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate interface whose topological grid is the expanded comp grid, currently with buffer of 4h for PERIODIC and SUBDOMAIN boundary, 1h for other boundaries. Install crossings of the interface and the expanded dual grid and store them in the interface table. These crossings can be used to interact with various PDE solvers.  <a href="#ga70d43787e4dee696c039d4286a904c5c">More...</a><br/></td></tr>
<tr class="separator:ga70d43787e4dee696c039d4286a904c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0fe6684156687dc8243a16f2a7972fa"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaa0fe6684156687dc8243a16f2a7972fa">FT_FreeCompGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:gaa0fe6684156687dc8243a16f2a7972fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space of grid crossing interface made by the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga70d43787e4dee696c039d4286a904c5c" title="Make a duplicate interface whose topological grid is the expanded comp grid, currently with buffer of...">FT_MakeCompGridIntfc()</a>.  <a href="#gaa0fe6684156687dc8243a16f2a7972fa">More...</a><br/></td></tr>
<tr class="separator:gaa0fe6684156687dc8243a16f2a7972fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff71f10a5ea191217f1fa302e8c14224"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaff71f10a5ea191217f1fa302e8c14224">FT_FreeOldGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:gaff71f10a5ea191217f1fa302e8c14224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space of grid crossing interface of front-&gt;old_grid_intfc.  <a href="#gaff71f10a5ea191217f1fa302e8c14224">More...</a><br/></td></tr>
<tr class="separator:gaff71f10a5ea191217f1fa302e8c14224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a4043d1a692d4650b0e70e08c481fa"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gae8a4043d1a692d4650b0e70e08c481fa">FT_FreeFront</a> (Front *front)</td></tr>
<tr class="memdesc:gae8a4043d1a692d4650b0e70e08c481fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space occupied by the front including grid_intfc if still there, and interf.  <a href="#gae8a4043d1a692d4650b0e70e08c481fa">More...</a><br/></td></tr>
<tr class="separator:gae8a4043d1a692d4650b0e70e08c481fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0d075bfe9d713fce5c71763bc38de8"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaed0d075bfe9d713fce5c71763bc38de8">FT_FreeMainIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:gaed0d075bfe9d713fce5c71763bc38de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space occupied by the primary interface of the front.  <a href="#gaed0d075bfe9d713fce5c71763bc38de8">More...</a><br/></td></tr>
<tr class="separator:gaed0d075bfe9d713fce5c71763bc38de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48a7313099d778293353fdc04359f2b"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaf48a7313099d778293353fdc04359f2b">FT_NormalAtGridCrossing</a> (Front *front, int *icoords, GRID_DIRECTION dir, int comp, double *nor, HYPER_SURF **hs, double *crx_coords)</td></tr>
<tr class="memdesc:gaf48a7313099d778293353fdc04359f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface cross on the grid line segment. The function returns YES if the crossing exists, in such case, the crossing coordinates are copied to crx_coords, the corresponding hyper surface (curce in 2D and surface in 3D) is assigned to hs, and the normal vector to the side of comp. If no crossing exists, the function return NO;.  <a href="#gaf48a7313099d778293353fdc04359f2b">More...</a><br/></td></tr>
<tr class="separator:gaf48a7313099d778293353fdc04359f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331030b5a78063e6acce46c964c5c0eb"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga331030b5a78063e6acce46c964c5c0eb">FT_StateStructAtGridCrossing</a> (Front *front, INTERFACE *grid_intfc, int *icoords, GRID_DIRECTION dir, int comp, POINTER *state, HYPER_SURF **hs, double *crx_coords)</td></tr>
<tr class="memdesc:ga331030b5a78063e6acce46c964c5c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface cross on the grid line segment. The function returns YES if the crossing exists, in such case, the crossing coordinates are copied to crx_coords, the corresponding hyper surface (curce in 2D and surface in 3D) is assigned to hs, and the state on the side of comp is assigned to the state pointer. If no crossing exists, the function return NO;.  <a href="#ga331030b5a78063e6acce46c964c5c0eb">More...</a><br/></td></tr>
<tr class="separator:ga331030b5a78063e6acce46c964c5c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b2369dfb9a72ad2d67103408c7d7e5"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga24b2369dfb9a72ad2d67103408c7d7e5">FT_StateVarAtGridCrossing</a> (Front *front, int *icoords, GRID_DIRECTION dir, int comp, double(*state_func)(Locstate), double *ans, double *crx_coords)</td></tr>
<tr class="memdesc:ga24b2369dfb9a72ad2d67103408c7d7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the same way as the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga331030b5a78063e6acce46c964c5c0eb" title="Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface...">FT_StateStructAtGridCrossing()</a> except it assigns a specific state variable instead of the whole state structure. Since front does not know the state structure of application, an application specific state retrieving function state_func() must be supplied.  <a href="#ga24b2369dfb9a72ad2d67103408c7d7e5">More...</a><br/></td></tr>
<tr class="separator:ga24b2369dfb9a72ad2d67103408c7d7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a4412d35cf4e8ba70f40ee8e021213"><td class="memItemLeft" align="right" valign="top">IMPORT HYPER_SURF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga99a4412d35cf4e8ba70f40ee8e021213">FT_HyperSurfAtGridCrossing</a> (Front *front, int *icoords, GRID_DIRECTION dir, int wave_type)</td></tr>
<tr class="memdesc:ga99a4412d35cf4e8ba70f40ee8e021213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sitting at icoords and look to the direction dir, this function detects the nearest hyper surface (curve in 2D and surface in 3D) on the grid segment. Return pointer to hyper surface if there is one, return NULL if no crossing hyper surface is found.  <a href="#ga99a4412d35cf4e8ba70f40ee8e021213">More...</a><br/></td></tr>
<tr class="separator:ga99a4412d35cf4e8ba70f40ee8e021213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0e84e0bbe322e0344144904b2d971b"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga4a0e84e0bbe322e0344144904b2d971b">FT_IntrpStateVarAtCoords</a> (Front *front, int comp, double *coords, double *var_array, double(*state_func)(POINTER), double *ans, double *default_ans)</td></tr>
<tr class="memdesc:ga4a0e84e0bbe322e0344144904b2d971b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a state variable at a space point with coords. If comp == NO_COMP, it interpolates with no regard of interface. Otherwise it will interpolate in the subdomain of comp. The state_func() is needed to tell the function how to retrieve the variable from the interface state. The interpolated variable is assigned in ans. Return YES if the interpolation is successful.  <a href="#ga4a0e84e0bbe322e0344144904b2d971b">More...</a><br/></td></tr>
<tr class="separator:ga4a0e84e0bbe322e0344144904b2d971b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8502ad50741cbb47b859d2a74421e4b"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaf8502ad50741cbb47b859d2a74421e4b">FT_CompGridIntrpStateVarAtCoords</a> (Front *front, int comp, double *coords, double *var_array, double(*state_func)(POINTER), double *ans, double *default_ans)</td></tr>
<tr class="memdesc:gaf8502ad50741cbb47b859d2a74421e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a state variable at a space point with coords on computational grid. If comp == NO_COMP, it interpolates with no regard of interface. Otherwise it will interpolate in the subdomain of comp. The state_func() is needed to tell the function how to retrieve the variable from the interface state. The interpolated variable is assigned in ans. Return YES if the interpolation is successful.  <a href="#gaf8502ad50741cbb47b859d2a74421e4b">More...</a><br/></td></tr>
<tr class="separator:gaf8502ad50741cbb47b859d2a74421e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9baf36c34acc36c027840cbbf80370"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2d9baf36c34acc36c027840cbbf80370">FT_NearestRectGridVarInRange</a> (Front *front, int comp, double *coords, double *var_array, int range, double *ans)</td></tr>
<tr class="memdesc:ga2d9baf36c34acc36c027840cbbf80370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the state variable on rectangular grid point which has the same component as the input and is nearest to the input coordinate. Return YES if such point is found, and NO if no such point is found. In the latter case, the value of the ans is set to zero.  <a href="#ga2d9baf36c34acc36c027840cbbf80370">More...</a><br/></td></tr>
<tr class="separator:ga2d9baf36c34acc36c027840cbbf80370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cff2b36e5edbc1abd70fcb05b3eb76d"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga1cff2b36e5edbc1abd70fcb05b3eb76d">FT_FindNearestIntfcPointInRange</a> (Front *front, int comp, double *coords, USE_BOUNDARIES bdry, double *intfc_point, double *t, HYPER_SURF_ELEMENT **hse, HYPER_SURF **hs, int range)</td></tr>
<tr class="memdesc:ga1cff2b36e5edbc1abd70fcb05b3eb76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a space coordinate coords, this function tries to find the nearest point on the interface within range, together with its associated hyper surface element (bond in 2D and triangle in 3D) and hyper surface (curve in 2D and surface in 3D). If no hyper surface is within range, the function returns NO;.  <a href="#ga1cff2b36e5edbc1abd70fcb05b3eb76d">More...</a><br/></td></tr>
<tr class="separator:ga1cff2b36e5edbc1abd70fcb05b3eb76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c00f63b4a54734de6eae4efae45bda"><td class="memItemLeft" align="right" valign="top">IMPORT double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga13c00f63b4a54734de6eae4efae45bda">FT_ComputeTotalVolumeFraction</a> (Front *front, COMPONENT comp_of_vol)</td></tr>
<tr class="memdesc:ga13c00f63b4a54734de6eae4efae45bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the total volume fraction associated the comp_of_vol based on crossing in front-&gt;grid_intfc. It returns the total volume fraction as a double precision value.  <a href="#ga13c00f63b4a54734de6eae4efae45bda">More...</a><br/></td></tr>
<tr class="separator:ga13c00f63b4a54734de6eae4efae45bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f55d47301bbcca08ccdd5706e6f286"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga84f55d47301bbcca08ccdd5706e6f286">FT_ComputeGridVolumeFraction</a> (Front *front, COMPONENT comp_of_vol, POINTER *grid_vol_frac)</td></tr>
<tr class="memdesc:ga84f55d47301bbcca08ccdd5706e6f286"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the volume fraction on the expanded dual grid associated the comp_of_vol based on crossing in front-&gt;grid_intfc. It passes the address of the grid volume fraction to the pointer grid_vol_frac. In 2D, it is a double**, in 3D it is double***.  <a href="#ga84f55d47301bbcca08ccdd5706e6f286">More...</a><br/></td></tr>
<tr class="separator:ga84f55d47301bbcca08ccdd5706e6f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ec67adaee0fd0b4498e0d0d2a36b40"><td class="memItemLeft" align="right" valign="top">IMPORT double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaa9ec67adaee0fd0b4498e0d0d2a36b40">FT_GridIntfcTopL</a> (Front *)</td></tr>
<tr class="memdesc:gaa9ec67adaee0fd0b4498e0d0d2a36b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return lower bounds of grid domain.  <a href="#gaa9ec67adaee0fd0b4498e0d0d2a36b40">More...</a><br/></td></tr>
<tr class="separator:gaa9ec67adaee0fd0b4498e0d0d2a36b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga906dd1fc0f6fcadadaea6f3950f0f642"><td class="memItemLeft" align="right" valign="top">IMPORT double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga906dd1fc0f6fcadadaea6f3950f0f642">FT_GridIntfcTopU</a> (Front *)</td></tr>
<tr class="memdesc:ga906dd1fc0f6fcadadaea6f3950f0f642"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return upper bounds of grid domain.  <a href="#ga906dd1fc0f6fcadadaea6f3950f0f642">More...</a><br/></td></tr>
<tr class="separator:ga906dd1fc0f6fcadadaea6f3950f0f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df01fa187bfed7f240c6883b356018c"><td class="memItemLeft" align="right" valign="top">IMPORT double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga7df01fa187bfed7f240c6883b356018c">FT_GridIntfcToph</a> (Front *)</td></tr>
<tr class="memdesc:ga7df01fa187bfed7f240c6883b356018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return grid spacing of grid domain.  <a href="#ga7df01fa187bfed7f240c6883b356018c">More...</a><br/></td></tr>
<tr class="separator:ga7df01fa187bfed7f240c6883b356018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ea92169c297b2b18f4db76d2fd9729"><td class="memItemLeft" align="right" valign="top">IMPORT COMPONENT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gae5ea92169c297b2b18f4db76d2fd9729">FT_GridIntfcTopComp</a> (Front *)</td></tr>
<tr class="memdesc:gae5ea92169c297b2b18f4db76d2fd9729"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return components of grid domain.  <a href="#gae5ea92169c297b2b18f4db76d2fd9729">More...</a><br/></td></tr>
<tr class="separator:gae5ea92169c297b2b18f4db76d2fd9729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd41d6d6171f1266b0381c6568ab884"><td class="memItemLeft" align="right" valign="top">IMPORT COMPONENT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga8fd41d6d6171f1266b0381c6568ab884">FT_GridIntfcTopGmax</a> (Front *)</td></tr>
<tr class="memdesc:ga8fd41d6d6171f1266b0381c6568ab884"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return mesh sizes of grid domain.  <a href="#ga8fd41d6d6171f1266b0381c6568ab884">More...</a><br/></td></tr>
<tr class="separator:ga8fd41d6d6171f1266b0381c6568ab884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6641e0a8a541513cdeb5cbd25a88a147"><td class="memItemLeft" align="right" valign="top">IMPORT RECT_GRID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga6641e0a8a541513cdeb5cbd25a88a147">FT_GridIntfcTopGrid</a> (Front *)</td></tr>
<tr class="memdesc:ga6641e0a8a541513cdeb5cbd25a88a147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return grid structure of grid domain.  <a href="#ga6641e0a8a541513cdeb5cbd25a88a147">More...</a><br/></td></tr>
<tr class="separator:ga6641e0a8a541513cdeb5cbd25a88a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf8502ad50741cbb47b859d2a74421e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_CompGridIntrpStateVarAtCoords </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(POINTER)&#160;</td>
          <td class="paramname"><em>state_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>default_ans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a state variable at a space point with coords on computational grid. If comp == NO_COMP, it interpolates with no regard of interface. Otherwise it will interpolate in the subdomain of comp. The state_func() is needed to tell the function how to retrieve the variable from the interface state. The interpolated variable is assigned in ans. Return YES if the interpolation is successful. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component in which the state should be interpolated. </td></tr>
    <tr><td class="paramname">coords</td><td><b>in</b> The coords at which interploation happens. </td></tr>
    <tr><td class="paramname">var_array</td><td><b>in</b> Array of the variable on the expanded dual grid. </td></tr>
    <tr><td class="paramname">state_func()</td><td><b>in</b> Function to retrieve the variable from the interface state pointer. </td></tr>
    <tr><td class="paramname">ans</td><td><b>out</b> Address of the interpolated variable. </td></tr>
    <tr><td class="paramname">default_ans</td><td><b>in</b> Address of default solution, if NULL, the function will look for solution at nearest interface point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84f55d47301bbcca08ccdd5706e6f286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FT_ComputeGridVolumeFraction </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>comp_of_vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">POINTER *&#160;</td>
          <td class="paramname"><em>grid_vol_frac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute the volume fraction on the expanded dual grid associated the comp_of_vol based on crossing in front-&gt;grid_intfc. It passes the address of the grid volume fraction to the pointer grid_vol_frac. In 2D, it is a double**, in 3D it is double***. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>pointer</b> to the front. </td></tr>
    <tr><td class="paramname">comp_of_vol</td><td><b>component</b> index of the volume fraction. </td></tr>
    <tr><td class="paramname">grid_vol_frac</td><td><b>ananomous</b> pointer pointing to the addess of the volume fraction on the grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13c00f63b4a54734de6eae4efae45bda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FT_ComputeTotalVolumeFraction </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>comp_of_vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute the total volume fraction associated the comp_of_vol based on crossing in front-&gt;grid_intfc. It returns the total volume fraction as a double precision value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>pointer</b> to the front. </td></tr>
    <tr><td class="paramname">comp_of_vol</td><td><b>component</b> index of the volume fraction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1cff2b36e5edbc1abd70fcb05b3eb76d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_FindNearestIntfcPointInRange </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USE_BOUNDARIES&#160;</td>
          <td class="paramname"><em>bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>intfc_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYPER_SURF_ELEMENT **&#160;</td>
          <td class="paramname"><em>hse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYPER_SURF **&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a space coordinate coords, this function tries to find the nearest point on the interface within range, together with its associated hyper surface element (bond in 2D and triangle in 3D) and hyper surface (curve in 2D and surface in 3D). If no hyper surface is within range, the function returns NO;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component index of the space coordinates. </td></tr>
    <tr><td class="paramname">coords</td><td><b>in</b> Coordinates of the space point. </td></tr>
    <tr><td class="paramname">bdry</td><td><b>in</b> Whether boundary hypersurface should be used. </td></tr>
    <tr><td class="paramname">intfc_point</td><td><b>out</b> Coordinates of the nearest point on the interface. </td></tr>
    <tr><td class="paramname">t</td><td><b>out</b> Interpolation factors. </td></tr>
    <tr><td class="paramname">hse</td><td><b>out</b> Residing hyper surface element (bond in 2D and tri in 3D). </td></tr>
    <tr><td class="paramname">hs</td><td><b>out</b> Residing hyper surface (curve in 2D and surface in 3D). </td></tr>
    <tr><td class="paramname">range</td><td><b>in</b> Range for the search in unit of grid spacing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa0fe6684156687dc8243a16f2a7972fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_FreeCompGridIntfc </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete and free space of grid crossing interface made by the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga70d43787e4dee696c039d4286a904c5c" title="Make a duplicate interface whose topological grid is the expanded comp grid, currently with buffer of...">FT_MakeCompGridIntfc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae8a4043d1a692d4650b0e70e08c481fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_FreeFront </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete and free space occupied by the front including grid_intfc if still there, and interf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03dfa34f5478d732b91a297188a6bfb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_FreeGridIntfc </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete and free space of grid crossing interface made by the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2bac4ec588ff38cb9ac1abba111146c9" title="Make a duplicate interface whose topological grid is the expanded dual grid, currently with buffer of...">FT_MakeGridIntfc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaed0d075bfe9d713fce5c71763bc38de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_FreeMainIntfc </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete and free space occupied by the primary interface of the front. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaff71f10a5ea191217f1fa302e8c14224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_FreeOldGridIntfc </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete and free space of grid crossing interface of front-&gt;old_grid_intfc. </p>
<ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gae5ea92169c297b2b18f4db76d2fd9729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">COMPONENT * FT_GridIntfcTopComp </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return components of grid domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8fd41d6d6171f1266b0381c6568ab884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * FT_GridIntfcTopGmax </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return mesh sizes of grid domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6641e0a8a541513cdeb5cbd25a88a147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RECT_GRID * FT_GridIntfcTopGrid </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return grid structure of grid domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7df01fa187bfed7f240c6883b356018c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * FT_GridIntfcToph </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return grid spacing of grid domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9ec67adaee0fd0b4498e0d0d2a36b40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * FT_GridIntfcTopL </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return lower bounds of grid domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga906dd1fc0f6fcadadaea6f3950f0f642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * FT_GridIntfcTopU </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return upper bounds of grid domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga99a4412d35cf4e8ba70f40ee8e021213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HYPER_SURF * FT_HyperSurfAtGridCrossing </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>icoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRID_DIRECTION&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wave_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sitting at icoords and look to the direction dir, this function detects the nearest hyper surface (curve in 2D and surface in 3D) on the grid segment. Return pointer to hyper surface if there is one, return NULL if no crossing hyper surface is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">icoords</td><td><b>in</b> Grid point coordinate indices. </td></tr>
    <tr><td class="paramname">dir</td><td><b>in</b> Direction to which the crossing is to be found. </td></tr>
    <tr><td class="paramname">wave_type</td><td><b>in</b> wave type of the hyper surface to search, if ANY_WAVE_TYPE, will return any hyper surface at the crossing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a0e84e0bbe322e0344144904b2d971b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_IntrpStateVarAtCoords </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(POINTER)&#160;</td>
          <td class="paramname"><em>state_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>default_ans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a state variable at a space point with coords. If comp == NO_COMP, it interpolates with no regard of interface. Otherwise it will interpolate in the subdomain of comp. The state_func() is needed to tell the function how to retrieve the variable from the interface state. The interpolated variable is assigned in ans. Return YES if the interpolation is successful. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component in which the state should be interpolated. </td></tr>
    <tr><td class="paramname">coords</td><td><b>in</b> The coords at which interpolation happens. </td></tr>
    <tr><td class="paramname">var_array</td><td><b>in</b> Array of the variable on the expanded dual grid. </td></tr>
    <tr><td class="paramname">state_func()</td><td><b>in</b> Function to retrieve the variable from the interface state pointer. </td></tr>
    <tr><td class="paramname">ans</td><td><b>out</b> Address of the interpolated variable. </td></tr>
    <tr><td class="paramname">default_ans</td><td><b>in</b> Address of default solution, if NULL, the function will look for solution at nearest interface point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70d43787e4dee696c039d4286a904c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeCompGridIntfc </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a duplicate interface whose topological grid is the expanded comp grid, currently with buffer of 4h for PERIODIC and SUBDOMAIN boundary, 1h for other boundaries. Install crossings of the interface and the expanded dual grid and store them in the interface table. These crossings can be used to interact with various PDE solvers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2bac4ec588ff38cb9ac1abba111146c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeGridIntfc </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a duplicate interface whose topological grid is the expanded dual grid, currently with buffer of 4h for PERIODIC and SUBDOMAIN boundary, 1h for other boundaries. Install crossings of the interface and the expanded dual grid and store them in the interface table. These crossings can be used to interact with various PDE solvers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to Front. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d9baf36c34acc36c027840cbbf80370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_NearestRectGridVarInRange </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the state variable on rectangular grid point which has the same component as the input and is nearest to the input coordinate. Return YES if such point is found, and NO if no such point is found. In the latter case, the value of the ans is set to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component in which the state should be interpolated. </td></tr>
    <tr><td class="paramname">coords</td><td><b>in</b> Input coordinates. </td></tr>
    <tr><td class="paramname">var_array</td><td><b>in</b> Array of the variable on the expanded dual grid. </td></tr>
    <tr><td class="paramname">range</td><td><b>in</b> Rnage of search in number of grid cells. </td></tr>
    <tr><td class="paramname">ans</td><td><b>out</b> Address of the interpolated variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf48a7313099d778293353fdc04359f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_NormalAtGridCrossing </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>icoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRID_DIRECTION&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYPER_SURF **&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>crx_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface cross on the grid line segment. The function returns YES if the crossing exists, in such case, the crossing coordinates are copied to crx_coords, the corresponding hyper surface (curce in 2D and surface in 3D) is assigned to hs, and the normal vector to the side of comp. If no crossing exists, the function return NO;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">icoords</td><td><b>in</b> Grid point coordinate indices. </td></tr>
    <tr><td class="paramname">dir</td><td><b>in</b> Direction to which the crossing is to be found. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component (domain index) of the grid point at icoord. </td></tr>
    <tr><td class="paramname">nor</td><td><b>out</b> normal vector at the crossing to the side of comp. </td></tr>
    <tr><td class="paramname">hs</td><td><b>out</b> Crossing hyper surface (curve in 2D and surface in 3D). </td></tr>
    <tr><td class="paramname">crx_coords</td><td><b>out</b> Crossing coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga331030b5a78063e6acce46c964c5c0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_StateStructAtGridCrossing </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTERFACE *&#160;</td>
          <td class="paramname"><em>grid_intfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>icoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRID_DIRECTION&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">POINTER *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYPER_SURF **&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>crx_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface cross on the grid line segment. The function returns YES if the crossing exists, in such case, the crossing coordinates are copied to crx_coords, the corresponding hyper surface (curce in 2D and surface in 3D) is assigned to hs, and the state on the side of comp is assigned to the state pointer. If no crossing exists, the function return NO;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_intfc</td><td><b>in</b> Pointer to Interface. </td></tr>
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">icoords</td><td><b>in</b> Grid point coordinate indices. </td></tr>
    <tr><td class="paramname">dir</td><td><b>in</b> Direction to which the crossing is to be found. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component (domain index) of the grid point at icoord. </td></tr>
    <tr><td class="paramname">state</td><td><b>out</b> State at the crossing on the side of comp. </td></tr>
    <tr><td class="paramname">hs</td><td><b>out</b> Crossing hyper surface (curve in 2D and surface in 3D). </td></tr>
    <tr><td class="paramname">crx_coords</td><td><b>out</b> Crossing coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24b2369dfb9a72ad2d67103408c7d7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean FT_StateVarAtGridCrossing </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>icoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRID_DIRECTION&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(Locstate)&#160;</td>
          <td class="paramname"><em>state_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>crx_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the same way as the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga331030b5a78063e6acce46c964c5c0eb" title="Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface...">FT_StateStructAtGridCrossing()</a> except it assigns a specific state variable instead of the whole state structure. Since front does not know the state structure of application, an application specific state retrieving function state_func() must be supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>in</b> Pointer to Front. </td></tr>
    <tr><td class="paramname">icoords</td><td><b>in</b> Grid point coordinate indices. </td></tr>
    <tr><td class="paramname">dir</td><td><b>in</b> Direction to which the crossing is to be found. </td></tr>
    <tr><td class="paramname">comp</td><td><b>in</b> Component (domain index) of the grid point at icoord. </td></tr>
    <tr><td class="paramname">state_func</td><td><b>in</b> State function for the requested state variable. </td></tr>
    <tr><td class="paramname">ans</td><td><b>out</b> The answer </td></tr>
    <tr><td class="paramname">crx_coords</td><td><b>out</b> Crossing coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 14 2015 11:00:23 for FronTier++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>

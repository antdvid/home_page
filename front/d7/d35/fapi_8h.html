<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>FronTier++: FronTier++/src/front/fapi.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FronTier++
   </div>
   <div id="projectbrief">Softerware for front tracking method</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_57fb008e0ec5a6d1cbbede75ffdd6c32.html">FronTier++</a></li><li class="navelem"><a class="el" href="../../dir_384bf429c27d37bc287fdfa7727d21b1.html">src</a></li><li class="navelem"><a class="el" href="../../dir_bcf756a75379ed2f41e7df137df3605d.html">front</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fapi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="../../d7/d35/fapi_8h.html" title="The fapi.h contains the functions used to operate the interface. ">fapi.h</a> contains the functions used to operate the interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;front/fdecs.h&gt;</code><br/>
</div>
<p><a href="../../d7/d35/fapi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaabc3a4a619100a7f79ccab041e56f13c"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gaabc3a4a619100a7f79ccab041e56f13c">FT_Init</a> (int argc, char **argv, F_BASIC_DATA *f_basic)</td></tr>
<tr class="memdesc:gaabc3a4a619100a7f79ccab041e56f13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the command line arguments, set IO handles, and store initialization parameters in f_basic, Including read the number of processors, the dimesension of the problem, partition of the computational domain, restart message, the input file and the output directory. -d dim -p nx [ny] [nz] -i input-name -o output-dir-name -r restart-dir-name -t restart-step.  <a href="../../d4/d54/group__INITIALIZATION.html#gaabc3a4a619100a7f79ccab041e56f13c">More...</a><br/></td></tr>
<tr class="separator:gaabc3a4a619100a7f79ccab041e56f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0c9eacbefffd97c78270a99028fcc4"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga9f0c9eacbefffd97c78270a99028fcc4">FT_ReadSpaceDomain</a> (char *in_name, F_BASIC_DATA *f_basic)</td></tr>
<tr class="memdesc:ga9f0c9eacbefffd97c78270a99028fcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from input file the computational domain information of the problem, including the domain limits, computational grid, and the types of the rectangular boundaries. The information is stored in the structure f_basic.  <a href="../../d4/d54/group__INITIALIZATION.html#ga9f0c9eacbefffd97c78270a99028fcc4">More...</a><br/></td></tr>
<tr class="separator:ga9f0c9eacbefffd97c78270a99028fcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5691571dfcb374f3bfd1bab6e2185ae5"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga5691571dfcb374f3bfd1bab6e2185ae5">FT_ReadComparisonDomain</a> (char *in_name, F_BASIC_DATA *f_basic)</td></tr>
<tr class="memdesc:ga5691571dfcb374f3bfd1bab6e2185ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from input file the comparison domain information of the problem, including the domain limits, computational grid, and the types of the rectangular boundaries. The information is stored in the structure f_basic.  <a href="../../d4/d54/group__INITIALIZATION.html#ga5691571dfcb374f3bfd1bab6e2185ae5">More...</a><br/></td></tr>
<tr class="separator:ga5691571dfcb374f3bfd1bab6e2185ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506f3542260db3b0a8ed36d5132835e3"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga506f3542260db3b0a8ed36d5132835e3">FT_StartUp</a> (Front *front, F_BASIC_DATA *f_basic)</td></tr>
<tr class="memdesc:ga506f3542260db3b0a8ed36d5132835e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize front computational grid, interface and function hooks, default function calls, and if restart, read interface from restart directory. Constructor for Front object.  <a href="../../d4/d54/group__INITIALIZATION.html#ga506f3542260db3b0a8ed36d5132835e3">More...</a><br/></td></tr>
<tr class="separator:ga506f3542260db3b0a8ed36d5132835e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689d30333f9c5885405c00cd5c19bdec"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga689d30333f9c5885405c00cd5c19bdec">FT_InitDebug</a> (char *inname)</td></tr>
<tr class="memdesc:ga689d30333f9c5885405c00cd5c19bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize strings for debugging option of the problem, read the input file.  <a href="../../d4/d54/group__INITIALIZATION.html#ga689d30333f9c5885405c00cd5c19bdec">More...</a><br/></td></tr>
<tr class="separator:ga689d30333f9c5885405c00cd5c19bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d0d72516f4d3312a9cd3e4bfdb3552"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga51d0d72516f4d3312a9cd3e4bfdb3552">FT_InitIntfc</a> (Front *front, LEVEL_FUNC_PACK *level_func_pack)</td></tr>
<tr class="memdesc:ga51d0d72516f4d3312a9cd3e4bfdb3552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the interface interface curves (2D) and surfaces (3D) using level function and parameters, or in some cases, point set. Install boundary curves (2D) or surfaces (3D). For 2D, the boundary is installed by default. For 3D, the boundary is installed on request.  <a href="../../d4/d54/group__INITIALIZATION.html#ga51d0d72516f4d3312a9cd3e4bfdb3552">More...</a><br/></td></tr>
<tr class="separator:ga51d0d72516f4d3312a9cd3e4bfdb3552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c959dd0460cbcafda590a48e9a75e7a"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga2c959dd0460cbcafda590a48e9a75e7a">FT_ClipIntfcToSubdomain</a> (Front *front)</td></tr>
<tr class="memdesc:ga2c959dd0460cbcafda590a48e9a75e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip the Initial interface of the front to a parallel subdomain.  <a href="../../d4/d54/group__INITIALIZATION.html#ga2c959dd0460cbcafda590a48e9a75e7a">More...</a><br/></td></tr>
<tr class="separator:ga2c959dd0460cbcafda590a48e9a75e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5d78422a8649b43a530adbef947254"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga1a5d78422a8649b43a530adbef947254">FT_InitVeloFunc</a> (Front *front, VELO_FUNC_PACK *velo_func_pack)</td></tr>
<tr class="memdesc:ga1a5d78422a8649b43a530adbef947254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize front velocity function for front point propagation. The velocity function use point and other related structures as input, must also supply parameters needed for the velocity function.  <a href="../../d4/d54/group__INITIALIZATION.html#ga1a5d78422a8649b43a530adbef947254">More...</a><br/></td></tr>
<tr class="separator:ga1a5d78422a8649b43a530adbef947254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f9af5003ddf2150954b97148607186"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga62f9af5003ddf2150954b97148607186">FT_ReadTimeControl</a> (char *in_name, Front *front)</td></tr>
<tr class="memdesc:ga62f9af5003ddf2150954b97148607186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the time domain and control information from input file, including maximum time, maximum step, restart print interval, movie frame output interval, CFL factor, and redistribution step interval.  <a href="../../d4/d54/group__INITIALIZATION.html#ga62f9af5003ddf2150954b97148607186">More...</a><br/></td></tr>
<tr class="separator:ga62f9af5003ddf2150954b97148607186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3858581907803fab14abd2c3addbcfdb"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga3858581907803fab14abd2c3addbcfdb">FT_ResetTime</a> (Front *front)</td></tr>
<tr class="memdesc:ga3858581907803fab14abd2c3addbcfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the time to 0.0, time step to 0, print interval index to 0, movie interval index to 0.  <a href="../../d4/d54/group__INITIALIZATION.html#ga3858581907803fab14abd2c3addbcfdb">More...</a><br/></td></tr>
<tr class="separator:ga3858581907803fab14abd2c3addbcfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9c6b8ce8c744c05f0d4f7a9bbf9c2e"><td class="memItemLeft" align="right" valign="top">IMPORT POINTER *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gaeb9c6b8ce8c744c05f0d4f7a9bbf9c2e">FT_CreateLevelHyperSurfs</a> (RECT_GRID *rgr, INTERFACE *intfc, int neg_comp, int pos_comp, double(*func)(POINTER, double *), POINTER func_params, int w_type, int *num_hs)</td></tr>
<tr class="memdesc:gaeb9c6b8ce8c744c05f0d4f7a9bbf9c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a set of hypersurfaces (curves in 2D and surfaces in 3D) using a level function (provided by the caller). The function return the handle for the array of hyper surfaces as (POINTER*).  <a href="../../d4/d54/group__INITIALIZATION.html#gaeb9c6b8ce8c744c05f0d4f7a9bbf9c2e">More...</a><br/></td></tr>
<tr class="separator:gaeb9c6b8ce8c744c05f0d4f7a9bbf9c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7f34093dfd543ebd66b2ccff8742cd"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9a/group__PROPAGATION.html#ga0c7f34093dfd543ebd66b2ccff8742cd">FT_Propagate</a> (Front *front)</td></tr>
<tr class="memdesc:ga0c7f34093dfd543ebd66b2ccff8742cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate the Front for one time step. The process includes advancing the front forward by one step to new positions, redistributing new interface mesh and resolving physical and topological bifurcations. The interface in the front is replaced by a new and propagated one and the old one is freed.  <a href="../../d5/d9a/group__PROPAGATION.html#ga0c7f34093dfd543ebd66b2ccff8742cd">More...</a><br/></td></tr>
<tr class="separator:ga0c7f34093dfd543ebd66b2ccff8742cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378a767ef50a2da96f44719ac4789f71"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga378a767ef50a2da96f44719ac4789f71">FT_RedistMesh</a> (Front *front)</td></tr>
<tr class="memdesc:ga378a767ef50a2da96f44719ac4789f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an independent call for redistribution and optimization of the interface mesh. A parallel communication of front should be called following this call to ensure that the redistribution is consistent globally.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga378a767ef50a2da96f44719ac4789f71">More...</a><br/></td></tr>
<tr class="separator:ga378a767ef50a2da96f44719ac4789f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d878dcf2802c64619bf0f524e002f61"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga3d878dcf2802c64619bf0f524e002f61">FT_OptimizeMesh</a> (Front *front, SCALED_REDIST_PARAMS params)</td></tr>
<tr class="memdesc:ga3d878dcf2802c64619bf0f524e002f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an independent call for redistribution and optimization of the interface mesh. A parallel communication of front should be called following this call to ensure that the redistribution is consistent globally. The function will redistribute all curves and surfaces (3D). It will recursively do either 10 times or when nothing to be done.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga3d878dcf2802c64619bf0f524e002f61">More...</a><br/></td></tr>
<tr class="separator:ga3d878dcf2802c64619bf0f524e002f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3cdb7ef9b0e6e8acd1ab613c10d5c4"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga8b3cdb7ef9b0e6e8acd1ab613c10d5c4">FT_OptimizeSurfMesh</a> (Front *front, SURFACE *surf, SCALED_REDIST_PARAMS params)</td></tr>
<tr class="memdesc:ga8b3cdb7ef9b0e6e8acd1ab613c10d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an independent call for redistribution and optimization of a surf mesh. No parallel communication is called after redistribution. Return YES (nothing_done == YES) if no more triangle to be redistributed.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga8b3cdb7ef9b0e6e8acd1ab613c10d5c4">More...</a><br/></td></tr>
<tr class="separator:ga8b3cdb7ef9b0e6e8acd1ab613c10d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826694560bce061d09012c44002c3031"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga826694560bce061d09012c44002c3031">FT_OptimizeCurveMesh</a> (Front *front, CURVE *curve, SCALED_REDIST_PARAMS params)</td></tr>
<tr class="memdesc:ga826694560bce061d09012c44002c3031"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an independent call for redistribution and optimization of a curve mesh. No parallel communication is called after redistribution. Return YES (nothing_done == YES) if no more bond to be redistributed.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga826694560bce061d09012c44002c3031">More...</a><br/></td></tr>
<tr class="separator:ga826694560bce061d09012c44002c3031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21cd4b5d3a9f3a6d36b028c998804291"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga21cd4b5d3a9f3a6d36b028c998804291">FT_SetCurveSpacing</a> (Front *front, double scaled_spacing)</td></tr>
<tr class="memdesc:ga21cd4b5d3a9f3a6d36b028c998804291"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the optimal spacing for curve redistribution. The scaled spacing is in the unit of regular grid spacing h.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga21cd4b5d3a9f3a6d36b028c998804291">More...</a><br/></td></tr>
<tr class="separator:ga21cd4b5d3a9f3a6d36b028c998804291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c10b62e5748339743fd4f685ab8be17"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga3c10b62e5748339743fd4f685ab8be17">FT_OptimizeCurveMeshWithEqualBonds</a> (Front *front, CURVE *curve)</td></tr>
<tr class="memdesc:ga3c10b62e5748339743fd4f685ab8be17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an independent call for redistribution and optimization of curve. A parallel communication of front should be called following this call to ensure that the redistribution is consistent globally.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga3c10b62e5748339743fd4f685ab8be17">More...</a><br/></td></tr>
<tr class="separator:ga3c10b62e5748339743fd4f685ab8be17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09741004fb2b7edfeb175a53c99c9b0a"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__TIME.html#ga09741004fb2b7edfeb175a53c99c9b0a">FT_SetTimeStep</a> (Front *front)</td></tr>
<tr class="memdesc:ga09741004fb2b7edfeb175a53c99c9b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate front-&gt;dt for next time step using the recorded maximum speed from previous time step, it step is reduced by a CFL factor to to ensure numerical stability.  <a href="../../dd/d10/group__TIME.html#ga09741004fb2b7edfeb175a53c99c9b0a">More...</a><br/></td></tr>
<tr class="separator:ga09741004fb2b7edfeb175a53c99c9b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca82d7da0f0c28cada6f5d7abf30930"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga3ca82d7da0f0c28cada6f5d7abf30930">FT_SetOutputCounter</a> (Front *front)</td></tr>
<tr class="memdesc:ga3ca82d7da0f0c28cada6f5d7abf30930"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used in restart to set the printing index and movie output index to appropiate number according to the restart time.  <a href="../../d4/d54/group__INITIALIZATION.html#ga3ca82d7da0f0c28cada6f5d7abf30930">More...</a><br/></td></tr>
<tr class="separator:ga3ca82d7da0f0c28cada6f5d7abf30930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd79a047c81eb97b79756e6798bde8e3"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__TIME.html#gadd79a047c81eb97b79756e6798bde8e3">FT_TimeControlFilter</a> (Front *front)</td></tr>
<tr class="memdesc:gadd79a047c81eb97b79756e6798bde8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">To further reduce time step if the printing or movie output time is smaller than the time after next time step. Increment priting or/and movie output index if either of both of them are met.  <a href="../../dd/d10/group__TIME.html#gadd79a047c81eb97b79756e6798bde8e3">More...</a><br/></td></tr>
<tr class="separator:gadd79a047c81eb97b79756e6798bde8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa75f808bfc48b58cef67f5db0e63b20"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__TIME.html#gaaa75f808bfc48b58cef67f5db0e63b20">FT_IsSaveTime</a> (Front *front)</td></tr>
<tr class="memdesc:gaaa75f808bfc48b58cef67f5db0e63b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that time is reached for printing restart files. returns YES to indicate that restart file should be generated. This function does not write the output.  <a href="../../dd/d10/group__TIME.html#gaaa75f808bfc48b58cef67f5db0e63b20">More...</a><br/></td></tr>
<tr class="separator:gaaa75f808bfc48b58cef67f5db0e63b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefbf5f750cbf1d02b7e1e15fb76954e9"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__TIME.html#gaefbf5f750cbf1d02b7e1e15fb76954e9">FT_IsMovieFrameTime</a> (Front *front)</td></tr>
<tr class="memdesc:gaefbf5f750cbf1d02b7e1e15fb76954e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that time is reached for output of a movie frame. returns YES to indicate that a movie frame should be generated. This function does not write the movie frame.  <a href="../../dd/d10/group__TIME.html#gaefbf5f750cbf1d02b7e1e15fb76954e9">More...</a><br/></td></tr>
<tr class="separator:gaefbf5f750cbf1d02b7e1e15fb76954e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869ebe5c3c2fbd15767e266febe88e46"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__TIME.html#ga869ebe5c3c2fbd15767e266febe88e46">FT_TimeLimitReached</a> (Front *front)</td></tr>
<tr class="memdesc:ga869ebe5c3c2fbd15767e266febe88e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that time is reached for termination of the run. Return YES either maximum time has been reached or maximum time step has been reached.  <a href="../../dd/d10/group__TIME.html#ga869ebe5c3c2fbd15767e266febe88e46">More...</a><br/></td></tr>
<tr class="separator:ga869ebe5c3c2fbd15767e266febe88e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f007ed6e3de95b1e56c8f925b740a0c"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__TIME.html#ga9f007ed6e3de95b1e56c8f925b740a0c">FT_RecordMaxFrontSpeed</a> (int dir, double speed, POINTER state, double *coords, Front *front)</td></tr>
<tr class="memdesc:ga9f007ed6e3de95b1e56c8f925b740a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compare and record maximum speed of the front. The recorded speed will be used to determine the time step which must satisfy the CFL condition.  <a href="../../dd/d10/group__TIME.html#ga9f007ed6e3de95b1e56c8f925b740a0c">More...</a><br/></td></tr>
<tr class="separator:ga9f007ed6e3de95b1e56c8f925b740a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51834b9206a288347040fe15e719e295"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9a/group__PROPAGATION.html#ga51834b9206a288347040fe15e719e295">FT_AddTimeStepToCounter</a> (Front *front)</td></tr>
<tr class="memdesc:ga51834b9206a288347040fe15e719e295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add front-&gt;dt to front-&gt;time after propagation.  <a href="../../d5/d9a/group__PROPAGATION.html#ga51834b9206a288347040fe15e719e295">More...</a><br/></td></tr>
<tr class="separator:ga51834b9206a288347040fe15e719e295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7ac13ea02e0f3844ebcb1a9efc60c0"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d71/group__OUTPUT.html#gafd7ac13ea02e0f3844ebcb1a9efc60c0">FT_Save</a> (Front *front, char *out_name)</td></tr>
<tr class="memdesc:gafd7ac13ea02e0f3844ebcb1a9efc60c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output front geometric data to the directory of out_name. The data can be used for restart of the run.  <a href="../../de/d71/group__OUTPUT.html#gafd7ac13ea02e0f3844ebcb1a9efc60c0">More...</a><br/></td></tr>
<tr class="separator:gafd7ac13ea02e0f3844ebcb1a9efc60c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad32bc73d7f3427bc42db9a86a7fad142"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d71/group__OUTPUT.html#gad32bc73d7f3427bc42db9a86a7fad142">FT_AddMovieFrame</a> (Front *front, char *out_name, boolean binary)</td></tr>
<tr class="memdesc:gad32bc73d7f3427bc42db9a86a7fad142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a movie frame, currently includes GD, hdf, vtk formats.  <a href="../../de/d71/group__OUTPUT.html#gad32bc73d7f3427bc42db9a86a7fad142">More...</a><br/></td></tr>
<tr class="separator:gad32bc73d7f3427bc42db9a86a7fad142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb501b23f143596c39ede7060bb06db"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d71/group__OUTPUT.html#ga4eb501b23f143596c39ede7060bb06db">FT_XgraphSampleLine</a> (char *dirname, char *varname, boolean data_in_domain, int size, double *x, double *var)</td></tr>
<tr class="memdesc:ga4eb501b23f143596c39ede7060bb06db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function output variable sample along a grid line as xgraph data file. It considers parallelization of subdomains.  <a href="../../de/d71/group__OUTPUT.html#ga4eb501b23f143596c39ede7060bb06db">More...</a><br/></td></tr>
<tr class="separator:ga4eb501b23f143596c39ede7060bb06db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bac4ec588ff38cb9ac1abba111146c9"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2bac4ec588ff38cb9ac1abba111146c9">FT_MakeGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:ga2bac4ec588ff38cb9ac1abba111146c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate interface whose topological grid is the expanded dual grid, currently with buffer of 4h for PERIODIC and SUBDOMAIN boundary, 1h for other boundaries. Install crossings of the interface and the expanded dual grid and store them in the interface table. These crossings can be used to interact with various PDE solvers.  <a href="../../de/dba/group__GRIDINTFC.html#ga2bac4ec588ff38cb9ac1abba111146c9">More...</a><br/></td></tr>
<tr class="separator:ga2bac4ec588ff38cb9ac1abba111146c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03dfa34f5478d732b91a297188a6bfb5"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga03dfa34f5478d732b91a297188a6bfb5">FT_FreeGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:ga03dfa34f5478d732b91a297188a6bfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space of grid crossing interface made by the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2bac4ec588ff38cb9ac1abba111146c9" title="Make a duplicate interface whose topological grid is the expanded dual grid, currently with buffer of...">FT_MakeGridIntfc()</a>.  <a href="../../de/dba/group__GRIDINTFC.html#ga03dfa34f5478d732b91a297188a6bfb5">More...</a><br/></td></tr>
<tr class="separator:ga03dfa34f5478d732b91a297188a6bfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d43787e4dee696c039d4286a904c5c"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga70d43787e4dee696c039d4286a904c5c">FT_MakeCompGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:ga70d43787e4dee696c039d4286a904c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate interface whose topological grid is the expanded comp grid, currently with buffer of 4h for PERIODIC and SUBDOMAIN boundary, 1h for other boundaries. Install crossings of the interface and the expanded dual grid and store them in the interface table. These crossings can be used to interact with various PDE solvers.  <a href="../../de/dba/group__GRIDINTFC.html#ga70d43787e4dee696c039d4286a904c5c">More...</a><br/></td></tr>
<tr class="separator:ga70d43787e4dee696c039d4286a904c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0fe6684156687dc8243a16f2a7972fa"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaa0fe6684156687dc8243a16f2a7972fa">FT_FreeCompGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:gaa0fe6684156687dc8243a16f2a7972fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space of grid crossing interface made by the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga70d43787e4dee696c039d4286a904c5c" title="Make a duplicate interface whose topological grid is the expanded comp grid, currently with buffer of...">FT_MakeCompGridIntfc()</a>.  <a href="../../de/dba/group__GRIDINTFC.html#gaa0fe6684156687dc8243a16f2a7972fa">More...</a><br/></td></tr>
<tr class="separator:gaa0fe6684156687dc8243a16f2a7972fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff71f10a5ea191217f1fa302e8c14224"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaff71f10a5ea191217f1fa302e8c14224">FT_FreeOldGridIntfc</a> (Front *front)</td></tr>
<tr class="memdesc:gaff71f10a5ea191217f1fa302e8c14224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space of grid crossing interface of front-&gt;old_grid_intfc.  <a href="../../de/dba/group__GRIDINTFC.html#gaff71f10a5ea191217f1fa302e8c14224">More...</a><br/></td></tr>
<tr class="separator:gaff71f10a5ea191217f1fa302e8c14224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a4043d1a692d4650b0e70e08c481fa"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gae8a4043d1a692d4650b0e70e08c481fa">FT_FreeFront</a> (Front *front)</td></tr>
<tr class="memdesc:gae8a4043d1a692d4650b0e70e08c481fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete and free space occupied by the front including grid_intfc if still there, and interf.  <a href="../../de/dba/group__GRIDINTFC.html#gae8a4043d1a692d4650b0e70e08c481fa">More...</a><br/></td></tr>
<tr class="separator:gae8a4043d1a692d4650b0e70e08c481fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48a7313099d778293353fdc04359f2b"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaf48a7313099d778293353fdc04359f2b">FT_NormalAtGridCrossing</a> (Front *front, int *icoords, GRID_DIRECTION dir, int comp, double *nor, HYPER_SURF **hs, double *crx_coords)</td></tr>
<tr class="memdesc:gaf48a7313099d778293353fdc04359f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface cross on the grid line segment. The function returns YES if the crossing exists, in such case, the crossing coordinates are copied to crx_coords, the corresponding hyper surface (curce in 2D and surface in 3D) is assigned to hs, and the normal vector to the side of comp. If no crossing exists, the function return NO;.  <a href="../../de/dba/group__GRIDINTFC.html#gaf48a7313099d778293353fdc04359f2b">More...</a><br/></td></tr>
<tr class="separator:gaf48a7313099d778293353fdc04359f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331030b5a78063e6acce46c964c5c0eb"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga331030b5a78063e6acce46c964c5c0eb">FT_StateStructAtGridCrossing</a> (Front *front, INTERFACE *grid_intfc, int *icoords, GRID_DIRECTION dir, int comp, POINTER *state, HYPER_SURF **hs, double *crx_coords)</td></tr>
<tr class="memdesc:ga331030b5a78063e6acce46c964c5c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface cross on the grid line segment. The function returns YES if the crossing exists, in such case, the crossing coordinates are copied to crx_coords, the corresponding hyper surface (curce in 2D and surface in 3D) is assigned to hs, and the state on the side of comp is assigned to the state pointer. If no crossing exists, the function return NO;.  <a href="../../de/dba/group__GRIDINTFC.html#ga331030b5a78063e6acce46c964c5c0eb">More...</a><br/></td></tr>
<tr class="separator:ga331030b5a78063e6acce46c964c5c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b2369dfb9a72ad2d67103408c7d7e5"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga24b2369dfb9a72ad2d67103408c7d7e5">FT_StateVarAtGridCrossing</a> (Front *front, int *icoords, GRID_DIRECTION dir, int comp, double(*state_func)(Locstate), double *ans, double *crx_coords)</td></tr>
<tr class="memdesc:ga24b2369dfb9a72ad2d67103408c7d7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the same way as the function <a class="el" href="../../de/dba/group__GRIDINTFC.html#ga331030b5a78063e6acce46c964c5c0eb" title="Standing at grid icoords, looking to the direction dir, this function looks for the nearest interface...">FT_StateStructAtGridCrossing()</a> except it assigns a specific state variable instead of the whole state structure. Since front does not know the state structure of application, an application specific state retrieving function state_func() must be supplied.  <a href="../../de/dba/group__GRIDINTFC.html#ga24b2369dfb9a72ad2d67103408c7d7e5">More...</a><br/></td></tr>
<tr class="separator:ga24b2369dfb9a72ad2d67103408c7d7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a4412d35cf4e8ba70f40ee8e021213"><td class="memItemLeft" align="right" valign="top">IMPORT HYPER_SURF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga99a4412d35cf4e8ba70f40ee8e021213">FT_HyperSurfAtGridCrossing</a> (Front *front, int *icoords, GRID_DIRECTION dir, int wave_type)</td></tr>
<tr class="memdesc:ga99a4412d35cf4e8ba70f40ee8e021213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sitting at icoords and look to the direction dir, this function detects the nearest hyper surface (curve in 2D and surface in 3D) on the grid segment. Return pointer to hyper surface if there is one, return NULL if no crossing hyper surface is found.  <a href="../../de/dba/group__GRIDINTFC.html#ga99a4412d35cf4e8ba70f40ee8e021213">More...</a><br/></td></tr>
<tr class="separator:ga99a4412d35cf4e8ba70f40ee8e021213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0e84e0bbe322e0344144904b2d971b"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga4a0e84e0bbe322e0344144904b2d971b">FT_IntrpStateVarAtCoords</a> (Front *front, int comp, double *coords, double *var_array, double(*state_func)(POINTER), double *ans, double *default_ans)</td></tr>
<tr class="memdesc:ga4a0e84e0bbe322e0344144904b2d971b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a state variable at a space point with coords. If comp == NO_COMP, it interpolates with no regard of interface. Otherwise it will interpolate in the subdomain of comp. The state_func() is needed to tell the function how to retrieve the variable from the interface state. The interpolated variable is assigned in ans. Return YES if the interpolation is successful.  <a href="../../de/dba/group__GRIDINTFC.html#ga4a0e84e0bbe322e0344144904b2d971b">More...</a><br/></td></tr>
<tr class="separator:ga4a0e84e0bbe322e0344144904b2d971b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8502ad50741cbb47b859d2a74421e4b"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaf8502ad50741cbb47b859d2a74421e4b">FT_CompGridIntrpStateVarAtCoords</a> (Front *front, int comp, double *coords, double *var_array, double(*state_func)(POINTER), double *ans, double *default_ans)</td></tr>
<tr class="memdesc:gaf8502ad50741cbb47b859d2a74421e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a state variable at a space point with coords on computational grid. If comp == NO_COMP, it interpolates with no regard of interface. Otherwise it will interpolate in the subdomain of comp. The state_func() is needed to tell the function how to retrieve the variable from the interface state. The interpolated variable is assigned in ans. Return YES if the interpolation is successful.  <a href="../../de/dba/group__GRIDINTFC.html#gaf8502ad50741cbb47b859d2a74421e4b">More...</a><br/></td></tr>
<tr class="separator:gaf8502ad50741cbb47b859d2a74421e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9baf36c34acc36c027840cbbf80370"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga2d9baf36c34acc36c027840cbbf80370">FT_NearestRectGridVarInRange</a> (Front *front, int comp, double *coords, double *var_array, int range, double *ans)</td></tr>
<tr class="memdesc:ga2d9baf36c34acc36c027840cbbf80370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the state variable on rectangular grid point which has the same component as the input and is nearest to the input coordinate. Return YES if such point is found, and NO if no such point is found. In the latter case, the value of the ans is set to zero.  <a href="../../de/dba/group__GRIDINTFC.html#ga2d9baf36c34acc36c027840cbbf80370">More...</a><br/></td></tr>
<tr class="separator:ga2d9baf36c34acc36c027840cbbf80370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cff2b36e5edbc1abd70fcb05b3eb76d"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga1cff2b36e5edbc1abd70fcb05b3eb76d">FT_FindNearestIntfcPointInRange</a> (Front *front, int comp, double *coords, USE_BOUNDARIES bdry, double *intfc_point, double *t, HYPER_SURF_ELEMENT **hse, HYPER_SURF **hs, int range)</td></tr>
<tr class="memdesc:ga1cff2b36e5edbc1abd70fcb05b3eb76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a space coordinate coords, this function tries to find the nearest point on the interface within range, together with its associated hyper surface element (bond in 2D and triangle in 3D) and hyper surface (curve in 2D and surface in 3D). If no hyper surface is within range, the function returns NO;.  <a href="../../de/dba/group__GRIDINTFC.html#ga1cff2b36e5edbc1abd70fcb05b3eb76d">More...</a><br/></td></tr>
<tr class="separator:ga1cff2b36e5edbc1abd70fcb05b3eb76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062c15ef32cddf4e3afb55253a3b8cd1"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9e/group__GEOMETRY.html#ga062c15ef32cddf4e3afb55253a3b8cd1">FT_NormalAtPoint</a> (POINT *p, Front *front, double *normal, int comp)</td></tr>
<tr class="memdesc:ga062c15ef32cddf4e3afb55253a3b8cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normal vector at the point p.  <a href="../../db/d9e/group__GEOMETRY.html#ga062c15ef32cddf4e3afb55253a3b8cd1">More...</a><br/></td></tr>
<tr class="separator:ga062c15ef32cddf4e3afb55253a3b8cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a51e60553765389dc0450e69262c6e5"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9e/group__GEOMETRY.html#ga2a51e60553765389dc0450e69262c6e5">FT_CurvatureAtPoint</a> (POINT *p, Front *front, double *curvature)</td></tr>
<tr class="memdesc:ga2a51e60553765389dc0450e69262c6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the curvature at the point p.  <a href="../../db/d9e/group__GEOMETRY.html#ga2a51e60553765389dc0450e69262c6e5">More...</a><br/></td></tr>
<tr class="separator:ga2a51e60553765389dc0450e69262c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d4ea1b2375af651d0e98da238eb418"><td class="memItemLeft" align="right" valign="top">IMPORT double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9e/group__GEOMETRY.html#gaf8d4ea1b2375af651d0e98da238eb418">FT_GridSizeInDir</a> (double *dir, Front *front)</td></tr>
<tr class="memdesc:gaf8d4ea1b2375af651d0e98da238eb418"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grid size in direction dir is (dir dot h). If h are the same in all directions (square mesh), it returns the h.  <a href="../../db/d9e/group__GEOMETRY.html#gaf8d4ea1b2375af651d0e98da238eb418">More...</a><br/></td></tr>
<tr class="separator:gaf8d4ea1b2375af651d0e98da238eb418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2154d670e36c43759fa37724a3890d96"><td class="memItemLeft" align="right" valign="top">IMPORT Nor_stencil *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9e/group__GEOMETRY.html#ga2154d670e36c43759fa37724a3890d96">FT_CreateNormalStencil</a> (Front *front, POINT *p, int comp, int num_pts)</td></tr>
<tr class="memdesc:ga2154d670e36c43759fa37724a3890d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function create a normal stencil at the interface point p with size (number of points) num_pts. The normal stencil in in the ambient with component comp.  <a href="../../db/d9e/group__GEOMETRY.html#ga2154d670e36c43759fa37724a3890d96">More...</a><br/></td></tr>
<tr class="separator:ga2154d670e36c43759fa37724a3890d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7845d20e529f916b591757eba62672f8"><td class="memItemLeft" align="right" valign="top">IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9e/group__GEOMETRY.html#ga7845d20e529f916b591757eba62672f8">FT_ReflectPointThroughBdry</a> (Front *front, HYPER_SURF *hs, double *coords, int comp, double *coords_bdry, double *coords_ref, double *normal)</td></tr>
<tr class="memdesc:ga7845d20e529f916b591757eba62672f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the coordinates coords, this function find the reflected coordinates coordsrefl through the hypersurface hs, it also provide the normal vector nor at the reflection. Return NO if conditions not satisfied.  <a href="../../db/d9e/group__GEOMETRY.html#ga7845d20e529f916b591757eba62672f8">More...</a><br/></td></tr>
<tr class="separator:ga7845d20e529f916b591757eba62672f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f16e2a6047664dfea1d69701676476"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d79/group__BOUNDARY.html#ga04f16e2a6047664dfea1d69701676476">FT_SetDirichletBoundary</a> (Front *front, void(*state_func)(double *, HYPER_SURF *, Front *, POINTER, POINTER), const char *state_func_name, POINTER state_func_params, POINTER state, HYPER_SURF *hs)</td></tr>
<tr class="memdesc:ga04f16e2a6047664dfea1d69701676476"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets state of a Dirichlet boundary as a hyper surface. It provide two methods to set the boundary: (a) set the boundary with a constant state, in this case, the address of the state as a pointer must be supplied as a pointer while state_func, state_func_name and state_func_params must be set to NULL; (b) set the boundary state through a state function, in this case, state must be set to NULL while state_func, state_func_name and state_func_params must be supplied. Currently only flow-through and time-dependent functions are available.  <a href="../../d8/d79/group__BOUNDARY.html#ga04f16e2a6047664dfea1d69701676476">More...</a><br/></td></tr>
<tr class="separator:ga04f16e2a6047664dfea1d69701676476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060be793f512f0fa0217c9fed9484eba"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d79/group__BOUNDARY.html#ga060be793f512f0fa0217c9fed9484eba">FT_InsertDirichletBoundary</a> (Front *front, void(*state_func)(double *, HYPER_SURF *, Front *, POINTER, POINTER), const char *state_func_name, POINTER state_func_params, POINTER state, HYPER_SURF *hs, int index)</td></tr>
<tr class="memdesc:ga060be793f512f0fa0217c9fed9484eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function insert state to a Dirichlet boundary. The six (four for 2D) sides of the boundary memory has been allocated, this function fills in the content of the boundary state. It provide two methods to set the boundary: (a) set the boundary with a constant state, in this case, the address of the state as a pointer must be supplied as a pointer while state_func, state_func_name and state_func_params must be set to NULL; (b) set the boundary state through a state function, in this case, state must be set to NULL while state_func, state_func_name and state_func_params must be supplied. Currently only flow-through and time-dependent functions are available.  <a href="../../d8/d79/group__BOUNDARY.html#ga060be793f512f0fa0217c9fed9484eba">More...</a><br/></td></tr>
<tr class="separator:ga060be793f512f0fa0217c9fed9484eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54c91ffe6263b6da327ef983043a4f8"><td class="memItemLeft" align="right" valign="top">IMPORT HYPER_SURF **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d79/group__BOUNDARY.html#gaf54c91ffe6263b6da327ef983043a4f8">FT_MixedBoundaryHypSurfs</a> (INTERFACE *intfc, int idir, int nb, int w_type, int *num_hs)</td></tr>
<tr class="memdesc:gaf54c91ffe6263b6da327ef983043a4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a set of hyper surfaces (curves in 2D and surfaces in 3D) whose wave type matches the input w_type. If the boundary on idir and side nb is not MIXED_TYPE_BOUNDARY, the function returns NULL. Otherwise it will return an array of hyper surfaces. The function also assign num_hs, the total number of hyper surfaces in the returned set.  <a href="../../d8/d79/group__BOUNDARY.html#gaf54c91ffe6263b6da327ef983043a4f8">More...</a><br/></td></tr>
<tr class="separator:gaf54c91ffe6263b6da327ef983043a4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6e2321cddf21da04485200e47087e3"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d79/group__BOUNDARY.html#ga7e6e2321cddf21da04485200e47087e3">FT_PromptSetMixedTypeBoundary2d</a> (char *in_name, Front *front)</td></tr>
<tr class="memdesc:ga7e6e2321cddf21da04485200e47087e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the node types and curve wave types of nodes and curves at the MIXED_TYPE_BOUNDARY side(s). This function is only for 2D. It will prompt and set nodes in ascending order and then curves between the node pairs.  <a href="../../d8/d79/group__BOUNDARY.html#ga7e6e2321cddf21da04485200e47087e3">More...</a><br/></td></tr>
<tr class="separator:ga7e6e2321cddf21da04485200e47087e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9374ec9ecc9610a746e12284b4bd42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d9374ec9ecc9610a746e12284b4bd42"></a>
IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga4d9374ec9ecc9610a746e12284b4bd42">FT_Dimension</a> ()</td></tr>
<tr class="memdesc:ga4d9374ec9ecc9610a746e12284b4bd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the spatial dimension of current run. <br/></td></tr>
<tr class="separator:ga4d9374ec9ecc9610a746e12284b4bd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d60b2b7c1875fd799717fdee8ab42ee"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga1d60b2b7c1875fd799717fdee8ab42ee">FT_RectBoundaryType</a> (Front *front, int dir, int side)</td></tr>
<tr class="memdesc:ga1d60b2b7c1875fd799717fdee8ab42ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns rectangular boundary type in direction dir and side side.  <a href="../../d1/d33/group__QUERY.html#ga1d60b2b7c1875fd799717fdee8ab42ee">More...</a><br/></td></tr>
<tr class="separator:ga1d60b2b7c1875fd799717fdee8ab42ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga448da7f0f1046c2719bde3e7bbd8789a"><td class="memItemLeft" align="right" valign="top">IMPORT HYPER_SURF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga448da7f0f1046c2719bde3e7bbd8789a">FT_RectBoundaryHypSurf</a> (INTERFACE *intfc, int wave_type, int dir, int side)</td></tr>
<tr class="memdesc:ga448da7f0f1046c2719bde3e7bbd8789a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for a boundary hyper surface (curve in 2D and surface in 3D) at the rectangular domain border with the given wave type of the hyper surface in direction dir and side side. Returns NULL if no match is found and return pointer to the hyper surface if found.  <a href="../../d1/d33/group__QUERY.html#ga448da7f0f1046c2719bde3e7bbd8789a">More...</a><br/></td></tr>
<tr class="separator:ga448da7f0f1046c2719bde3e7bbd8789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284615aa684afaf4edc86afab5d0ac3d"><td class="memItemLeft" align="right" valign="top">IMPORT HYPER_SURF **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga284615aa684afaf4edc86afab5d0ac3d">FT_InteriorHypSurfs</a> (INTERFACE *intfc, int wave_type, int *num_hs)</td></tr>
<tr class="memdesc:ga284615aa684afaf4edc86afab5d0ac3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for interior hyper surfaces (curve in 2D and surface in 3D) with the given wave type. Returns NULL if no match is found and return pointer to an array of hyper surfaces if found. This function allocates the memory for the array of pointers to hyper surfaces.  <a href="../../d1/d33/group__QUERY.html#ga284615aa684afaf4edc86afab5d0ac3d">More...</a><br/></td></tr>
<tr class="separator:ga284615aa684afaf4edc86afab5d0ac3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f56672571ef59cb0be35967c460be8e"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga4f56672571ef59cb0be35967c460be8e">FT_ArrayOfIntfcCurves</a> (INTERFACE *intfc, CURVE **curve_array)</td></tr>
<tr class="memdesc:ga4f56672571ef59cb0be35967c460be8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function put all the handles (pointers) of curves in the intfc to an array (already allocated with memory) curve_array.  <a href="../../d1/d33/group__QUERY.html#ga4f56672571ef59cb0be35967c460be8e">More...</a><br/></td></tr>
<tr class="separator:ga4f56672571ef59cb0be35967c460be8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2039349c92878e260d0d3232d0c24203"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga2039349c92878e260d0d3232d0c24203">FT_ArrayOfCurvePoints</a> (CURVE *curve, POINT **point_array)</td></tr>
<tr class="memdesc:ga2039349c92878e260d0d3232d0c24203"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function put all the handles (pointers) of points on the curve to an array (already allocated with memory) point_array.  <a href="../../d1/d33/group__QUERY.html#ga2039349c92878e260d0d3232d0c24203">More...</a><br/></td></tr>
<tr class="separator:ga2039349c92878e260d0d3232d0c24203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee0e1dbcfc9a442dbb0e1fee99b4fae"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga6ee0e1dbcfc9a442dbb0e1fee99b4fae">FT_NumOfNodeCurves</a> (NODE *node)</td></tr>
<tr class="memdesc:ga6ee0e1dbcfc9a442dbb0e1fee99b4fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of curves attached to the node, including both in-curves and out curves.  <a href="../../d1/d33/group__QUERY.html#ga6ee0e1dbcfc9a442dbb0e1fee99b4fae">More...</a><br/></td></tr>
<tr class="separator:ga6ee0e1dbcfc9a442dbb0e1fee99b4fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7090b7b79ea5badcbba83f48c22666"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gaee7090b7b79ea5badcbba83f48c22666">FT_NumOfCurvePoints</a> (CURVE *curve)</td></tr>
<tr class="memdesc:gaee7090b7b79ea5badcbba83f48c22666"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of point on the curve including its nodes (closed node may be counted twice).  <a href="../../d1/d33/group__QUERY.html#gaee7090b7b79ea5badcbba83f48c22666">More...</a><br/></td></tr>
<tr class="separator:gaee7090b7b79ea5badcbba83f48c22666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad43f164dc90250d6ac6c8536db801601"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gad43f164dc90250d6ac6c8536db801601">FT_NumOfSurfPoints</a> (SURFACE *surf)</td></tr>
<tr class="memdesc:gad43f164dc90250d6ac6c8536db801601"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of point on the surface.  <a href="../../d1/d33/group__QUERY.html#gad43f164dc90250d6ac6c8536db801601">More...</a><br/></td></tr>
<tr class="separator:gad43f164dc90250d6ac6c8536db801601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3903407c883aae3f4d9d881d0c685cc"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gae3903407c883aae3f4d9d881d0c685cc">FT_NumOfIntfcPoints</a> (INTERFACE *intfc)</td></tr>
<tr class="memdesc:gae3903407c883aae3f4d9d881d0c685cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of point on the entire interface.  <a href="../../d1/d33/group__QUERY.html#gae3903407c883aae3f4d9d881d0c685cc">More...</a><br/></td></tr>
<tr class="separator:gae3903407c883aae3f4d9d881d0c685cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad039b582da0a979747a806715aabcf15"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gad039b582da0a979747a806715aabcf15">FT_NumOfIntfcNodes</a> (INTERFACE *intfc)</td></tr>
<tr class="memdesc:gad039b582da0a979747a806715aabcf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of node on the entire interface.  <a href="../../d1/d33/group__QUERY.html#gad039b582da0a979747a806715aabcf15">More...</a><br/></td></tr>
<tr class="separator:gad039b582da0a979747a806715aabcf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7123212fc81e8409b178e53d0941a946"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga7123212fc81e8409b178e53d0941a946">FT_NumOfCurveBonds</a> (CURVE *curve)</td></tr>
<tr class="memdesc:ga7123212fc81e8409b178e53d0941a946"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of bond on a curve of the front.  <a href="../../d1/d33/group__QUERY.html#ga7123212fc81e8409b178e53d0941a946">More...</a><br/></td></tr>
<tr class="separator:ga7123212fc81e8409b178e53d0941a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae259bd9072e278989500c3eee87ba1c"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gaae259bd9072e278989500c3eee87ba1c">FT_NumOfIntfcBonds</a> (INTERFACE *intfc)</td></tr>
<tr class="memdesc:gaae259bd9072e278989500c3eee87ba1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of bond on the entire interface of the front.  <a href="../../d1/d33/group__QUERY.html#gaae259bd9072e278989500c3eee87ba1c">More...</a><br/></td></tr>
<tr class="separator:gaae259bd9072e278989500c3eee87ba1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb18997c449c383f0dbfa17e80159746"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gabb18997c449c383f0dbfa17e80159746">FT_NumOfIntfcCurves</a> (INTERFACE *intfc)</td></tr>
<tr class="memdesc:gabb18997c449c383f0dbfa17e80159746"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of curves on the entire interface of the front.  <a href="../../d1/d33/group__QUERY.html#gabb18997c449c383f0dbfa17e80159746">More...</a><br/></td></tr>
<tr class="separator:gabb18997c449c383f0dbfa17e80159746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e89d9000938aa938c80df2bfb608c6"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga80e89d9000938aa938c80df2bfb608c6">FT_NumOfIntfcSurfaces</a> (INTERFACE *intfc)</td></tr>
<tr class="memdesc:ga80e89d9000938aa938c80df2bfb608c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of surfaces on the entire interface of the front.  <a href="../../d1/d33/group__QUERY.html#ga80e89d9000938aa938c80df2bfb608c6">More...</a><br/></td></tr>
<tr class="separator:ga80e89d9000938aa938c80df2bfb608c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fa81018080f61d1242431b5abe1e10"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gab8fa81018080f61d1242431b5abe1e10">FT_NumOfIntfcTris</a> (INTERFACE *intfc)</td></tr>
<tr class="memdesc:gab8fa81018080f61d1242431b5abe1e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of triangles on the entire interface of the front.  <a href="../../d1/d33/group__QUERY.html#gab8fa81018080f61d1242431b5abe1e10">More...</a><br/></td></tr>
<tr class="separator:gab8fa81018080f61d1242431b5abe1e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedec9f2bbc41428ca15ddee32caf6891"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gaedec9f2bbc41428ca15ddee32caf6891">FT_NumOfSurfTris</a> (SURFACE *surf)</td></tr>
<tr class="memdesc:gaedec9f2bbc41428ca15ddee32caf6891"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count number of triangles on the surface of the front.  <a href="../../d1/d33/group__QUERY.html#gaedec9f2bbc41428ca15ddee32caf6891">More...</a><br/></td></tr>
<tr class="separator:gaedec9f2bbc41428ca15ddee32caf6891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca1d64d064d0eb9f7cc41b67b950839"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gadca1d64d064d0eb9f7cc41b67b950839">FT_ArrayOfNodeCurves</a> (NODE *node, CURVE **curve_array)</td></tr>
<tr class="memdesc:gadca1d64d064d0eb9f7cc41b67b950839"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function put all the handles (pointers) of curves on the node to an array (already allocated with memory) curve_array.  <a href="../../d1/d33/group__QUERY.html#gadca1d64d064d0eb9f7cc41b67b950839">More...</a><br/></td></tr>
<tr class="separator:gadca1d64d064d0eb9f7cc41b67b950839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63660f62a81443ac9dbd5976771b278b"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga63660f62a81443ac9dbd5976771b278b">FT_ArrayOfCurveBonds</a> (CURVE *curve, BOND **bond_array)</td></tr>
<tr class="memdesc:ga63660f62a81443ac9dbd5976771b278b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function put all the handles (pointers) of bonds on the curve to an array (already allocated with memory) bond_array.  <a href="../../d1/d33/group__QUERY.html#ga63660f62a81443ac9dbd5976771b278b">More...</a><br/></td></tr>
<tr class="separator:ga63660f62a81443ac9dbd5976771b278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa471f7452622a683f1e56d7e668b4196"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gaa471f7452622a683f1e56d7e668b4196">FT_ArrayOfSurfPoints</a> (SURFACE *surf, POINT **point_array)</td></tr>
<tr class="memdesc:gaa471f7452622a683f1e56d7e668b4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function put all the handles (pointers) of points on the surface to an array (already allocated with memory) point_array.  <a href="../../d1/d33/group__QUERY.html#gaa471f7452622a683f1e56d7e668b4196">More...</a><br/></td></tr>
<tr class="separator:gaa471f7452622a683f1e56d7e668b4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac9d06b332226a1c6f88a836801f38b"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga9ac9d06b332226a1c6f88a836801f38b">FT_ArrayOfSurfCurves</a> (SURFACE *surf, CURVE **curve_array)</td></tr>
<tr class="memdesc:ga9ac9d06b332226a1c6f88a836801f38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function put all the handles (pointers) of curves on the surface to an array (already allocated with memory) curve_array.  <a href="../../d1/d33/group__QUERY.html#ga9ac9d06b332226a1c6f88a836801f38b">More...</a><br/></td></tr>
<tr class="separator:ga9ac9d06b332226a1c6f88a836801f38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d1723179238b2a05ebea5d97ce19dc"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga50d1723179238b2a05ebea5d97ce19dc">FT_NumOfSurfCurves</a> (SURFACE *surf)</td></tr>
<tr class="memdesc:ga50d1723179238b2a05ebea5d97ce19dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function count and return number of curves on the surface.  <a href="../../d1/d33/group__QUERY.html#ga50d1723179238b2a05ebea5d97ce19dc">More...</a><br/></td></tr>
<tr class="separator:ga50d1723179238b2a05ebea5d97ce19dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9621e2519f36c3f27a8dcb3948f54f2f"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga9621e2519f36c3f27a8dcb3948f54f2f">FT_FirstRingTrisAroundPoint</a> (POINT *p, TRI *tri, TRI ***tris)</td></tr>
<tr class="memdesc:ga9621e2519f36c3f27a8dcb3948f54f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for triangles in the first ring around the input point p, and return the number of tris in the first ring.  <a href="../../d1/d33/group__QUERY.html#ga9621e2519f36c3f27a8dcb3948f54f2f">More...</a><br/></td></tr>
<tr class="separator:ga9621e2519f36c3f27a8dcb3948f54f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b5fdcda4ce961541d5675b4bbd9e19"><td class="memItemLeft" align="right" valign="top">IMPORT CURVE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga82b5fdcda4ce961541d5675b4bbd9e19">FT_CurveOfPoint</a> (INTERFACE *intfc, POINT *point, BOND **bond)</td></tr>
<tr class="memdesc:ga82b5fdcda4ce961541d5675b4bbd9e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for the curve on which the point is located. If found, it will return the handle (pointer) of the curve, otherwise it will return NULL.  <a href="../../d1/d33/group__QUERY.html#ga82b5fdcda4ce961541d5675b4bbd9e19">More...</a><br/></td></tr>
<tr class="separator:ga82b5fdcda4ce961541d5675b4bbd9e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc19788c0b2abe61e6645c4333223e0"><td class="memItemLeft" align="right" valign="top">IMPORT NODE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#gaadc19788c0b2abe61e6645c4333223e0">FT_NodeOfPoint</a> (INTERFACE *intfc, POINT *point)</td></tr>
<tr class="memdesc:gaadc19788c0b2abe61e6645c4333223e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for the node on which the point is located. If found, it will return the handle (pointer) of the node, otherwise it will return NULL.  <a href="../../d1/d33/group__QUERY.html#gaadc19788c0b2abe61e6645c4333223e0">More...</a><br/></td></tr>
<tr class="separator:gaadc19788c0b2abe61e6645c4333223e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19fe575c3db8061a68071d9c0f36196"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3e/group__PARALLEL.html#gac19fe575c3db8061a68071d9c0f36196">FT_ParallelExchIntfcBuffer</a> (Front *front)</td></tr>
<tr class="memdesc:gac19fe575c3db8061a68071d9c0f36196"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a root level parallel communication function for front interface geometry and states. It will cut the old buffer parts of the interface and patch it with new parts received from other subdomains or periodically shifted sides. This is a synchronous function and must be called synchronously by every processor.  <a href="../../d7/d3e/group__PARALLEL.html#gac19fe575c3db8061a68071d9c0f36196">More...</a><br/></td></tr>
<tr class="separator:gac19fe575c3db8061a68071d9c0f36196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042f0a83036a09217d911c2c4b9f33b"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3e/group__PARALLEL.html#gaa042f0a83036a09217d911c2c4b9f33b">FT_ParallelExchGridArrayBuffer</a> (double *grid_array, Front *front, int *symmetry)</td></tr>
<tr class="memdesc:gaa042f0a83036a09217d911c2c4b9f33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a parallel communication function for a double array on the expanded dual grid of the grid_intfc in front. It will cut the old buffer parts of the array and patch it with new buffer parts received from other subdomains or periodically shifted sides. This is a synchronous function and must be called synchronously by every processor.  <a href="../../d7/d3e/group__PARALLEL.html#gaa042f0a83036a09217d911c2c4b9f33b">More...</a><br/></td></tr>
<tr class="separator:gaa042f0a83036a09217d911c2c4b9f33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59349c20bb1702967ded6600787ce63e"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3e/group__PARALLEL.html#ga59349c20bb1702967ded6600787ce63e">FT_ParallelExchCompGridArrayBuffer</a> (double *grid_array, Front *front, int *symmetry)</td></tr>
<tr class="memdesc:ga59349c20bb1702967ded6600787ce63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a parallel communication function for a double array on the expanded comp grid of the grid_intfc in front. It will cut the old buffer parts of the array and patch it with new buffer parts received from other subdomains or periodically shifted sides. This is a synchronous function and must be called synchronously by every processor.  <a href="../../d7/d3e/group__PARALLEL.html#ga59349c20bb1702967ded6600787ce63e">More...</a><br/></td></tr>
<tr class="separator:ga59349c20bb1702967ded6600787ce63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e302e94034858bbc5e3925afb2e1cb2"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3e/group__PARALLEL.html#ga5e302e94034858bbc5e3925afb2e1cb2">FT_ParallelExchCellIndex</a> (Front *front, int *lbuf, int *ubuf, POINTER ijk_to_I)</td></tr>
<tr class="memdesc:ga5e302e94034858bbc5e3925afb2e1cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a parallel communication function for the cell index on the expanded dual grid of the grid_intfc in front. The cell index translate the nD (n=2,3) icoordinates to a one dimensional index sequence. The indices are parallely globalized.  <a href="../../d7/d3e/group__PARALLEL.html#ga5e302e94034858bbc5e3925afb2e1cb2">More...</a><br/></td></tr>
<tr class="separator:ga5e302e94034858bbc5e3925afb2e1cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efb6c1cae43876327c0f8dfc35c4839"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3e/group__PARALLEL.html#ga2efb6c1cae43876327c0f8dfc35c4839">FT_ParallelExchCompGridCellIndex</a> (Front *front, int *lbuf, int *ubuf, POINTER ijk_to_I)</td></tr>
<tr class="memdesc:ga2efb6c1cae43876327c0f8dfc35c4839"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a parallel communication function for the dual cell index on the expanded comp grid of the comp_grid_intfc in front. The cell index translate the nD (n=2,3) icoordinates to a one dimensional index sequence. The indices are parallely globalized.  <a href="../../d7/d3e/group__PARALLEL.html#ga2efb6c1cae43876327c0f8dfc35c4839">More...</a><br/></td></tr>
<tr class="separator:ga2efb6c1cae43876327c0f8dfc35c4839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d421aa00940cf885ed1c7d0f4f5701"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d77/group__FIELD.html#ga01d421aa00940cf885ed1c7d0f4f5701">FT_GetStatesAtPoint</a> (POINT *p, HYPER_SURF_ELEMENT *hse, HYPER_SURF *hs, POINTER *sl, POINTER *sr)</td></tr>
<tr class="memdesc:ga01d421aa00940cf885ed1c7d0f4f5701"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the left and right states at a point. Since a point can be shared by different entities, the associated hyper surface element (bond in 2D and tri in 3D) and hyper surface (curve in 2D and surface in 3D) must be provided as input.  <a href="../../dc/d77/group__FIELD.html#ga01d421aa00940cf885ed1c7d0f4f5701">More...</a><br/></td></tr>
<tr class="separator:ga01d421aa00940cf885ed1c7d0f4f5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888f56a3301f51e6aac40f551baeb4be"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#ga888f56a3301f51e6aac40f551baeb4be">FT_ScalarMemoryAlloc</a> (POINTER *a, int size)</td></tr>
<tr class="memdesc:ga888f56a3301f51e6aac40f551baeb4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a scalar.  <a href="../../da/d61/group__MEMORY.html#ga888f56a3301f51e6aac40f551baeb4be">More...</a><br/></td></tr>
<tr class="separator:ga888f56a3301f51e6aac40f551baeb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga570eae212fd06f81b13cba40afab4f13"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#ga570eae212fd06f81b13cba40afab4f13">FT_VectorMemoryAlloc</a> (POINTER *a, int n1, int size)</td></tr>
<tr class="memdesc:ga570eae212fd06f81b13cba40afab4f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a vector.  <a href="../../da/d61/group__MEMORY.html#ga570eae212fd06f81b13cba40afab4f13">More...</a><br/></td></tr>
<tr class="separator:ga570eae212fd06f81b13cba40afab4f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf212e9156877eb00239c77ce67a1a605"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#gaf212e9156877eb00239c77ce67a1a605">FT_MatrixMemoryAlloc</a> (POINTER *a, int n1, int n2, int size)</td></tr>
<tr class="memdesc:gaf212e9156877eb00239c77ce67a1a605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a matrix.  <a href="../../da/d61/group__MEMORY.html#gaf212e9156877eb00239c77ce67a1a605">More...</a><br/></td></tr>
<tr class="separator:gaf212e9156877eb00239c77ce67a1a605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5793d460243dc938707cee6c3240ee"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#gabe5793d460243dc938707cee6c3240ee">FT_TriArrayMemoryAlloc</a> (POINTER *a, int n1, int n2, int n3, int size)</td></tr>
<tr class="memdesc:gabe5793d460243dc938707cee6c3240ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a tri-array.  <a href="../../da/d61/group__MEMORY.html#gabe5793d460243dc938707cee6c3240ee">More...</a><br/></td></tr>
<tr class="separator:gabe5793d460243dc938707cee6c3240ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae5a3f530c605b817da658e8125d349"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#gacae5a3f530c605b817da658e8125d349">FT_QuadArrayMemoryAlloc</a> (POINTER *a, int n1, int n2, int n3, int n4, int size)</td></tr>
<tr class="memdesc:gacae5a3f530c605b817da658e8125d349"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a quad-array.  <a href="../../da/d61/group__MEMORY.html#gacae5a3f530c605b817da658e8125d349">More...</a><br/></td></tr>
<tr class="separator:gacae5a3f530c605b817da658e8125d349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1eb9f91240b404f71aa5330a10db67"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#ga7d1eb9f91240b404f71aa5330a10db67">FT_QuinArrayMemoryAlloc</a> (POINTER *a, int n1, int n2, int n3, int n4, int n5, int size)</td></tr>
<tr class="memdesc:ga7d1eb9f91240b404f71aa5330a10db67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a quin-array.  <a href="../../da/d61/group__MEMORY.html#ga7d1eb9f91240b404f71aa5330a10db67">More...</a><br/></td></tr>
<tr class="separator:ga7d1eb9f91240b404f71aa5330a10db67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead680b732b97af8f9f87f68ce6a5a12"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#gaead680b732b97af8f9f87f68ce6a5a12">FT_SexArrayMemoryAlloc</a> (POINTER *a, int n1, int n2, int n3, int n4, int n5, int n6, int size)</td></tr>
<tr class="memdesc:gaead680b732b97af8f9f87f68ce6a5a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocate the memory for a sex-array.  <a href="../../da/d61/group__MEMORY.html#gaead680b732b97af8f9f87f68ce6a5a12">More...</a><br/></td></tr>
<tr class="separator:gaead680b732b97af8f9f87f68ce6a5a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga679e45f3721591450a189f73b5da582f"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#ga679e45f3721591450a189f73b5da582f">FT_SetGlobalIndex</a> (Front *front)</td></tr>
<tr class="memdesc:ga679e45f3721591450a189f73b5da582f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set global index for all point in the interface.  <a href="../../d4/d54/group__INITIALIZATION.html#ga679e45f3721591450a189f73b5da582f">More...</a><br/></td></tr>
<tr class="separator:ga679e45f3721591450a189f73b5da582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66158bee772523da70a72319d21ce78b"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/group__MEMORY.html#ga66158bee772523da70a72319d21ce78b">FT_FreeThese</a> (int n,...)</td></tr>
<tr class="memdesc:ga66158bee772523da70a72319d21ce78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function free memory of items allocated by FT_...MemoryAlloc() functions. The number of arguments is flexible, but needs to equal to the input integer n.  <a href="../../da/d61/group__MEMORY.html#ga66158bee772523da70a72319d21ce78b">More...</a><br/></td></tr>
<tr class="separator:ga66158bee772523da70a72319d21ce78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d15ab28942a5c4a5f167a1629d93df5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d15ab28942a5c4a5f167a1629d93df5"></a>
IMPORT boolean&#160;</td><td class="memItemRight" valign="bottom"><b>FT_StateStructAtGridCrossing2</b> (Front *front, int *icoords, GRID_DIRECTION dir, int comp, POINTER *state, HYPER_SURF **hs, HYPER_SURF_ELEMENT **hse, double *crx_coords)</td></tr>
<tr class="separator:a4d15ab28942a5c4a5f167a1629d93df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c00f63b4a54734de6eae4efae45bda"><td class="memItemLeft" align="right" valign="top">IMPORT double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga13c00f63b4a54734de6eae4efae45bda">FT_ComputeTotalVolumeFraction</a> (Front *front, COMPONENT comp_of_vol)</td></tr>
<tr class="memdesc:ga13c00f63b4a54734de6eae4efae45bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the total volume fraction associated the comp_of_vol based on crossing in front-&gt;grid_intfc. It returns the total volume fraction as a double precision value.  <a href="../../de/dba/group__GRIDINTFC.html#ga13c00f63b4a54734de6eae4efae45bda">More...</a><br/></td></tr>
<tr class="separator:ga13c00f63b4a54734de6eae4efae45bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f55d47301bbcca08ccdd5706e6f286"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga84f55d47301bbcca08ccdd5706e6f286">FT_ComputeGridVolumeFraction</a> (Front *front, COMPONENT comp_of_vol, POINTER *grid_vol_frac)</td></tr>
<tr class="memdesc:ga84f55d47301bbcca08ccdd5706e6f286"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the volume fraction on the expanded dual grid associated the comp_of_vol based on crossing in front-&gt;grid_intfc. It passes the address of the grid volume fraction to the pointer grid_vol_frac. In 2D, it is a double**, in 3D it is double***.  <a href="../../de/dba/group__GRIDINTFC.html#ga84f55d47301bbcca08ccdd5706e6f286">More...</a><br/></td></tr>
<tr class="separator:ga84f55d47301bbcca08ccdd5706e6f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476f95e9ffd195223a1aa5220ed601c2"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/group__OPTIMIZATION.html#ga476f95e9ffd195223a1aa5220ed601c2">FT_CurveSegLengthConstr</a> (CURVE *c, BOND *bs, BOND *be, int nb, double seg_length, REDISTRIBUTION_DIRECTION dir)</td></tr>
<tr class="memdesc:ga476f95e9ffd195223a1aa5220ed601c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set curve to constrained length (seg_length), starting from the bond bs and end at bond be, with total of nb bonds. The cutting direction is the input dir.  <a href="../../d8/dc0/group__OPTIMIZATION.html#ga476f95e9ffd195223a1aa5220ed601c2">More...</a><br/></td></tr>
<tr class="separator:ga476f95e9ffd195223a1aa5220ed601c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45eed609ecef08dbfda428b6de90e919"><td class="memItemLeft" align="right" valign="top">IMPORT CURVE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a45eed609ecef08dbfda428b6de90e919">FT_MakePointArrayCurve</a> (Front *front, int num_points, double **point_array, COMPONENT neg_comp, COMPONENT pos_comp, boolean is_closed_curve, int w_type)</td></tr>
<tr class="memdesc:a45eed609ecef08dbfda428b6de90e919"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a curve into the front with given array of points, if is_closed_curve is true, the curve is closed.  <a href="#a45eed609ecef08dbfda428b6de90e919">More...</a><br/></td></tr>
<tr class="separator:a45eed609ecef08dbfda428b6de90e919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b845d733ed98b219d4198a231613f0f"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a6b845d733ed98b219d4198a231613f0f">FT_MakeEllipticSurf</a> (Front *front, double *center, double *radius, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, int refinement_level, SURFACE **surf)</td></tr>
<tr class="memdesc:a6b845d733ed98b219d4198a231613f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts an elliptic surface into the front with given information of center, radii, components, and wave type.  <a href="#a6b845d733ed98b219d4198a231613f0f">More...</a><br/></td></tr>
<tr class="separator:a6b845d733ed98b219d4198a231613f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf56c5fa85ab3581898a7eccc66d04d"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a7bf56c5fa85ab3581898a7eccc66d04d">FT_MakeDumbBellSurf</a> (Front *front, double x0, double x1, double y0, double z0, double R, double r, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:a7bf56c5fa85ab3581898a7eccc66d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a dumbbell surface into the front with given information of its parameters, components, and wave type.  <a href="#a7bf56c5fa85ab3581898a7eccc66d04d">More...</a><br/></td></tr>
<tr class="separator:a7bf56c5fa85ab3581898a7eccc66d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08059891e7cebf0a930646fc756e47b2"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a08059891e7cebf0a930646fc756e47b2">FT_MakeProjectileSurf</a> (Front *front, double *center, double R, double r, double h, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:a08059891e7cebf0a930646fc756e47b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a projectile surface into the front with given information of its parameters, components, and wave type.  <a href="#a08059891e7cebf0a930646fc756e47b2">More...</a><br/></td></tr>
<tr class="separator:a08059891e7cebf0a930646fc756e47b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24736da558e60ebf875e5a1a18ac62cc"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a24736da558e60ebf875e5a1a18ac62cc">FT_RotateSurface</a> (SURFACE *surf, double *center, double phi, double theta)</td></tr>
<tr class="memdesc:a24736da558e60ebf875e5a1a18ac62cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function rorate surface with azimuthal angle theta and polar angle phi about the given center.  <a href="#a24736da558e60ebf875e5a1a18ac62cc">More...</a><br/></td></tr>
<tr class="separator:a24736da558e60ebf875e5a1a18ac62cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4da687fb3289c1ca6de8b4cba6a00d"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a8e4da687fb3289c1ca6de8b4cba6a00d">FT_MakeCuboidSurf</a> (Front *front, double *center, double *edge, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:a8e4da687fb3289c1ca6de8b4cba6a00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a cuboid surface into the front with given information of its parameters, components, and wave type.  <a href="#a8e4da687fb3289c1ca6de8b4cba6a00d">More...</a><br/></td></tr>
<tr class="separator:a8e4da687fb3289c1ca6de8b4cba6a00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbdd61c5bea13075191c3b7ff2426dd"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a9cbdd61c5bea13075191c3b7ff2426dd">FT_MakeCylinderSurf</a> (Front *front, double *center, double radius, double height, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:a9cbdd61c5bea13075191c3b7ff2426dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a cylinder surface into the front with given information of its parameters, components, and wave type.  <a href="#a9cbdd61c5bea13075191c3b7ff2426dd">More...</a><br/></td></tr>
<tr class="separator:a9cbdd61c5bea13075191c3b7ff2426dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f72ccf4820423173ed7bcc0a6f835e"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a27f72ccf4820423173ed7bcc0a6f835e">FT_MakeConeSurf</a> (Front *front, double *center, double slope, double height, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:a27f72ccf4820423173ed7bcc0a6f835e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a cone surface into the front with given information of its parameters, components, and wave type.  <a href="#a27f72ccf4820423173ed7bcc0a6f835e">More...</a><br/></td></tr>
<tr class="separator:a27f72ccf4820423173ed7bcc0a6f835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237e8c208063fd3a3a24039def4edfc"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a6237e8c208063fd3a3a24039def4edfc">FT_MakeTetrahedronSurf</a> (Front *front, double *center, double radius, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:a6237e8c208063fd3a3a24039def4edfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a tetrahedron surface into the front with given information of its parameters, components, and wave type.  <a href="#a6237e8c208063fd3a3a24039def4edfc">More...</a><br/></td></tr>
<tr class="separator:a6237e8c208063fd3a3a24039def4edfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca18050cae2258c81a5d62c2e1ca862"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#aaca18050cae2258c81a5d62c2e1ca862">FT_MakePlaneSurf</a> (Front *front, double *plane_nor, double *plane_pt, boolean reset_bdry_comp, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, SURFACE **surf)</td></tr>
<tr class="memdesc:aaca18050cae2258c81a5d62c2e1ca862"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts a plane surface into the front with given information of its parameters, components, and wave type.  <a href="#aaca18050cae2258c81a5d62c2e1ca862">More...</a><br/></td></tr>
<tr class="separator:aaca18050cae2258c81a5d62c2e1ca862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e53ff8e87c8f96ba5f0355a24e430f"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a35e53ff8e87c8f96ba5f0355a24e430f">FT_InstallSurfEdge</a> (SURFACE *surf, int hsbdry_type)</td></tr>
<tr class="memdesc:a35e53ff8e87c8f96ba5f0355a24e430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function install a curve at the surface boundary. The boundary of the surface should contain triangles with NULL side.  <a href="#a35e53ff8e87c8f96ba5f0355a24e430f">More...</a><br/></td></tr>
<tr class="separator:a35e53ff8e87c8f96ba5f0355a24e430f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5148db589cadcdca28d62fd31e37ac36"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a5148db589cadcdca28d62fd31e37ac36">FT_CutSurfBdry</a> (SURFACE *surf, boolean constr_func(POINTER, double *), POINTER func_params, double **insert_coords, int num_pts, int insert_idir)</td></tr>
<tr class="memdesc:a5148db589cadcdca28d62fd31e37ac36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function cut surface at the boundary defined by the constrain function. It first insert significant corner points to make sure it cuts the surface accurately.  <a href="#a5148db589cadcdca28d62fd31e37ac36">More...</a><br/></td></tr>
<tr class="separator:a5148db589cadcdca28d62fd31e37ac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfc9af10b00223d1bf65cab5aab5dd8"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/fapi_8h.html#a7cfc9af10b00223d1bf65cab5aab5dd8">FT_MakeEllipticCurve</a> (Front *front, double *center, double *radius, COMPONENT neg_comp, COMPONENT pos_comp, int w_type, int refinement_level, CURVE **curve)</td></tr>
<tr class="memdesc:a7cfc9af10b00223d1bf65cab5aab5dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts an elliptic curve into the front with given information of center, radii, components, and wave type.  <a href="#a7cfc9af10b00223d1bf65cab5aab5dd8">More...</a><br/></td></tr>
<tr class="separator:a7cfc9af10b00223d1bf65cab5aab5dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf747478cd8163dd8774aeb5fd9916d6c"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d15/group__INFO.html#gaf747478cd8163dd8774aeb5fd9916d6c">FT_PrintWaveType</a> (int w_type)</td></tr>
<tr class="memdesc:gaf747478cd8163dd8774aeb5fd9916d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function print wave type as a string.  <a href="../../d7/d15/group__INFO.html#gaf747478cd8163dd8774aeb5fd9916d6c">More...</a><br/></td></tr>
<tr class="separator:gaf747478cd8163dd8774aeb5fd9916d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8b1c6800c50ddeeb60ce53cba1e327d"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d15/group__INFO.html#gac8b1c6800c50ddeeb60ce53cba1e327d">FT_PrintBoundaryType</a> (int dir, int side)</td></tr>
<tr class="memdesc:gac8b1c6800c50ddeeb60ce53cba1e327d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function print boundary type as a string.  <a href="../../d7/d15/group__INFO.html#gac8b1c6800c50ddeeb60ce53cba1e327d">More...</a><br/></td></tr>
<tr class="separator:gac8b1c6800c50ddeeb60ce53cba1e327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e03a92306e9bed251fdefaa2c8f318"><td class="memItemLeft" align="right" valign="top">IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d33/group__QUERY.html#ga86e03a92306e9bed251fdefaa2c8f318">FT_BoundaryType</a> (int dir, int side)</td></tr>
<tr class="memdesc:ga86e03a92306e9bed251fdefaa2c8f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return boundary type as an enumerated.  <a href="../../d1/d33/group__QUERY.html#ga86e03a92306e9bed251fdefaa2c8f318">More...</a><br/></td></tr>
<tr class="separator:ga86e03a92306e9bed251fdefaa2c8f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ec67adaee0fd0b4498e0d0d2a36b40"><td class="memItemLeft" align="right" valign="top">IMPORT double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gaa9ec67adaee0fd0b4498e0d0d2a36b40">FT_GridIntfcTopL</a> (Front *)</td></tr>
<tr class="memdesc:gaa9ec67adaee0fd0b4498e0d0d2a36b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return lower bounds of grid domain.  <a href="../../de/dba/group__GRIDINTFC.html#gaa9ec67adaee0fd0b4498e0d0d2a36b40">More...</a><br/></td></tr>
<tr class="separator:gaa9ec67adaee0fd0b4498e0d0d2a36b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga906dd1fc0f6fcadadaea6f3950f0f642"><td class="memItemLeft" align="right" valign="top">IMPORT double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga906dd1fc0f6fcadadaea6f3950f0f642">FT_GridIntfcTopU</a> (Front *)</td></tr>
<tr class="memdesc:ga906dd1fc0f6fcadadaea6f3950f0f642"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return upper bounds of grid domain.  <a href="../../de/dba/group__GRIDINTFC.html#ga906dd1fc0f6fcadadaea6f3950f0f642">More...</a><br/></td></tr>
<tr class="separator:ga906dd1fc0f6fcadadaea6f3950f0f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df01fa187bfed7f240c6883b356018c"><td class="memItemLeft" align="right" valign="top">IMPORT double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga7df01fa187bfed7f240c6883b356018c">FT_GridIntfcToph</a> (Front *)</td></tr>
<tr class="memdesc:ga7df01fa187bfed7f240c6883b356018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return grid spacing of grid domain.  <a href="../../de/dba/group__GRIDINTFC.html#ga7df01fa187bfed7f240c6883b356018c">More...</a><br/></td></tr>
<tr class="separator:ga7df01fa187bfed7f240c6883b356018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ea92169c297b2b18f4db76d2fd9729"><td class="memItemLeft" align="right" valign="top">IMPORT COMPONENT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#gae5ea92169c297b2b18f4db76d2fd9729">FT_GridIntfcTopComp</a> (Front *)</td></tr>
<tr class="memdesc:gae5ea92169c297b2b18f4db76d2fd9729"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return components of grid domain.  <a href="../../de/dba/group__GRIDINTFC.html#gae5ea92169c297b2b18f4db76d2fd9729">More...</a><br/></td></tr>
<tr class="separator:gae5ea92169c297b2b18f4db76d2fd9729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd41d6d6171f1266b0381c6568ab884"><td class="memItemLeft" align="right" valign="top">IMPORT COMPONENT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga8fd41d6d6171f1266b0381c6568ab884">FT_GridIntfcTopGmax</a> (Front *)</td></tr>
<tr class="memdesc:ga8fd41d6d6171f1266b0381c6568ab884"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return mesh sizes of grid domain.  <a href="../../de/dba/group__GRIDINTFC.html#ga8fd41d6d6171f1266b0381c6568ab884">More...</a><br/></td></tr>
<tr class="separator:ga8fd41d6d6171f1266b0381c6568ab884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6641e0a8a541513cdeb5cbd25a88a147"><td class="memItemLeft" align="right" valign="top">IMPORT RECT_GRID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dba/group__GRIDINTFC.html#ga6641e0a8a541513cdeb5cbd25a88a147">FT_GridIntfcTopGrid</a> (Front *)</td></tr>
<tr class="memdesc:ga6641e0a8a541513cdeb5cbd25a88a147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return grid structure of grid domain.  <a href="../../de/dba/group__GRIDINTFC.html#ga6641e0a8a541513cdeb5cbd25a88a147">More...</a><br/></td></tr>
<tr class="separator:ga6641e0a8a541513cdeb5cbd25a88a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad987777e3ccafbf21eac99887362d924"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gad987777e3ccafbf21eac99887362d924">FT_AddHdfMovieVariable</a> (Front *front, boolean preset_bound, boolean untracked, COMPONENT obst_comp, const char *var_name, int idir, double *var_field, double(*getStateFunc)(POINTER), double max_var, double min_var)</td></tr>
<tr class="memdesc:gad987777e3ccafbf21eac99887362d924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a variable and information for hdf movie output.  <a href="../../d4/d54/group__INITIALIZATION.html#gad987777e3ccafbf21eac99887362d924">More...</a><br/></td></tr>
<tr class="separator:gad987777e3ccafbf21eac99887362d924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36db6cc7825fb05ec972758627c53af"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gaa36db6cc7825fb05ec972758627c53af">FT_AddVtkVectorMovieVariable</a> (Front *front, const char *var_name, double **var_field)</td></tr>
<tr class="memdesc:gaa36db6cc7825fb05ec972758627c53af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a variable and information for vtk vector movie output.  <a href="../../d4/d54/group__INITIALIZATION.html#gaa36db6cc7825fb05ec972758627c53af">More...</a><br/></td></tr>
<tr class="separator:gaa36db6cc7825fb05ec972758627c53af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30a6da66424927bdd6c9a5d8ab195f2"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gad30a6da66424927bdd6c9a5d8ab195f2">FT_AddVtkScalarMovieVariable</a> (Front *front, const char *var_name, double *var_field)</td></tr>
<tr class="memdesc:gad30a6da66424927bdd6c9a5d8ab195f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a variable and information for vtk scalar movie output.  <a href="../../d4/d54/group__INITIALIZATION.html#gad30a6da66424927bdd6c9a5d8ab195f2">More...</a><br/></td></tr>
<tr class="separator:gad30a6da66424927bdd6c9a5d8ab195f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae690a760cc56fa5dbf52104a59e67e33"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gae690a760cc56fa5dbf52104a59e67e33">FT_AddVtkIntfcMovieVariable</a> (Front *front, const char *var_name)</td></tr>
<tr class="memdesc:gae690a760cc56fa5dbf52104a59e67e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the variable name for vtk interface movie output.  <a href="../../d4/d54/group__INITIALIZATION.html#gae690a760cc56fa5dbf52104a59e67e33">More...</a><br/></td></tr>
<tr class="separator:gae690a760cc56fa5dbf52104a59e67e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab40fc0c15e05150d50c6f957979b592b"><td class="memItemLeft" align="right" valign="top">IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/group__INITIALIZATION.html#gab40fc0c15e05150d50c6f957979b592b">FT_ResetDomainAndGrid</a> (Front *front, double *L, double *U, int *gmax)</td></tr>
<tr class="memdesc:gab40fc0c15e05150d50c6f957979b592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset computational grid of front to new domain defined by input L,U, and gmax (mesh size). This function is used for modification of restart run. Caution: parallelization has not been considered.  <a href="../../d4/d54/group__INITIALIZATION.html#gab40fc0c15e05150d50c6f957979b592b">More...</a><br/></td></tr>
<tr class="separator:gab40fc0c15e05150d50c6f957979b592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="../../d7/d35/fapi_8h.html" title="The fapi.h contains the functions used to operate the interface. ">fapi.h</a> contains the functions used to operate the interface. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5148db589cadcdca28d62fd31e37ac36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_CutSurfBdry </td>
          <td>(</td>
          <td class="paramtype">SURFACE *&#160;</td>
          <td class="paramname"><em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean &#160;</td>
          <td class="paramname"><em>constr_func</em>POINTER, double *, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">POINTER&#160;</td>
          <td class="paramname"><em>func_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>insert_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>insert_idir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function cut surface at the boundary defined by the constrain function. It first insert significant corner points to make sure it cuts the surface accurately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surf</td><td><b>inout</b> Pointer to the surface to be cut. </td></tr>
    <tr><td class="paramname">constr_func</td><td><b>in</b> constrain function defining the boundary. </td></tr>
    <tr><td class="paramname">func_params</td><td><b>in</b> anonymous pointer of function parameters. </td></tr>
    <tr><td class="paramname">insert_coords</td><td><b>in</b> coordinates of points to be inserted before cut. </td></tr>
    <tr><td class="paramname">num_pts</td><td><b>in</b> number of points to be inserted before cut. </td></tr>
    <tr><td class="paramname">insert_idir</td><td><b>in</b> insert point along this direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35e53ff8e87c8f96ba5f0355a24e430f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_InstallSurfEdge </td>
          <td>(</td>
          <td class="paramtype">SURFACE *&#160;</td>
          <td class="paramname"><em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hsbdry_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function install a curve at the surface boundary. The boundary of the surface should contain triangles with NULL side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surf</td><td><b>inout</b> Pointer to the surface where edge to be installed. </td></tr>
    <tr><td class="paramname">hsbdry_type</td><td><b>in</b> Boundary curve type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27f72ccf4820423173ed7bcc0a6f835e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeConeSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a cone surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> vertex of the cone. </td></tr>
    <tr><td class="paramname">slope</td><td><b>in</b> slope of the cone. </td></tr>
    <tr><td class="paramname">height</td><td><b>in</b> height of the cone. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e4da687fb3289c1ca6de8b4cba6a00d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeCuboidSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a cuboid surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center of the cuboid. </td></tr>
    <tr><td class="paramname">edge</td><td><b>in</b> edge of the cuboid. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cbdd61c5bea13075191c3b7ff2426dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeCylinderSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a cylinder surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center of the cylinder. </td></tr>
    <tr><td class="paramname">edge</td><td><b>in</b> radius of the cylinder. </td></tr>
    <tr><td class="paramname">height</td><td><b>in</b> height of the cylinder. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bf56c5fa85ab3581898a7eccc66d04d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeDumbBellSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a dumbbell surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">x0</td><td><b>in</b> x-coordinate of the left center. </td></tr>
    <tr><td class="paramname">x0</td><td><b>in</b> x-coordinate of the right center. </td></tr>
    <tr><td class="paramname">y0</td><td><b>in</b> y-coordinate of the axis. </td></tr>
    <tr><td class="paramname">z0</td><td><b>in</b> z-coordinate of the axis. </td></tr>
    <tr><td class="paramname">R</td><td><b>in</b> radius of the two end spheres. </td></tr>
    <tr><td class="paramname">r</td><td><b>in</b> radius cylinder connecting the two spheres. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cfc9af10b00223d1bf65cab5aab5dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeEllipticCurve </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refinement_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CURVE **&#160;</td>
          <td class="paramname"><em>curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts an elliptic curve into the front with given information of center, radii, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which curve is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center of the ellipse. </td></tr>
    <tr><td class="paramname">radius</td><td><b>in</b> radii of the ellipse. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the curve (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the curve (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>int</b> wave type of the curve. </td></tr>
    <tr><td class="paramname">refinement_level</td><td><b>int</b> level of refinement. </td></tr>
    <tr><td class="paramname">curve</td><td><b>out</b> curve made by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b845d733ed98b219d4198a231613f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeEllipticSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refinement_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts an elliptic surface into the front with given information of center, radii, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center of the ellipsoid. </td></tr>
    <tr><td class="paramname">radius</td><td><b>in</b> radii of the ellipsoid. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>int</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">refinement_level</td><td><b>int</b> refinement level of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaca18050cae2258c81a5d62c2e1ca862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakePlaneSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plane_nor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plane_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>reset_bdry_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a plane surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">plane_nor</td><td><b>in</b> normal vector of the plane. </td></tr>
    <tr><td class="paramname">plane_pt</td><td><b>in</b> coordinates of a point on the plane. </td></tr>
    <tr><td class="paramname">reset_bdry_comp</td><td><b>in</b> if YES, reset boundary component. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45eed609ecef08dbfda428b6de90e919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CURVE * FT_MakePointArrayCurve </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>point_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>is_closed_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a curve into the front with given array of points, if is_closed_curve is true, the curve is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">num_points</td><td><b>in</b> number of points in the given array. </td></tr>
    <tr><td class="paramname">point_array</td><td><b>in</b> an array of point coordinates. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the curve (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the curve (outer side). </td></tr>
    <tr><td class="paramname">is_closed_curve</td><td><b>in</b> indicate whether the curve is closed. </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08059891e7cebf0a930646fc756e47b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeProjectileSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a projectile surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center-coordinate of the projectile. </td></tr>
    <tr><td class="paramname">R</td><td><b>in</b> cylindrical radius of the projectile. </td></tr>
    <tr><td class="paramname">r</td><td><b>in</b> head height of the projectile. </td></tr>
    <tr><td class="paramname">h</td><td><b>in</b> butt height of the projectile. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6237e8c208063fd3a3a24039def4edfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_MakeTetrahedronSurf </td>
          <td>(</td>
          <td class="paramtype">Front *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>neg_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPONENT&#160;</td>
          <td class="paramname"><em>pos_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SURFACE **&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts a tetrahedron surface into the front with given information of its parameters, components, and wave type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td><b>inout</b> Pointer to the front in which surface is inserted. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center of the tetrahedron. </td></tr>
    <tr><td class="paramname">radius</td><td><b>in</b> circumcircle of the tetrahedron. </td></tr>
    <tr><td class="paramname">neg_comp</td><td><b>in</b> index for negative side of the surface (inner side). </td></tr>
    <tr><td class="paramname">pos_comp</td><td><b>in</b> index for positive side of the surface (outer side). </td></tr>
    <tr><td class="paramname">w_type</td><td><b>in</b> wave type of the surface. </td></tr>
    <tr><td class="paramname">surf</td><td><b>out</b> surface made by this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24736da558e60ebf875e5a1a18ac62cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FT_RotateSurface </td>
          <td>(</td>
          <td class="paramtype">SURFACE *&#160;</td>
          <td class="paramname"><em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function rorate surface with azimuthal angle theta and polar angle phi about the given center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surf</td><td><b>inout</b> Pointer to the surface to be rotated. </td></tr>
    <tr><td class="paramname">center</td><td><b>in</b> center-coordinate for the rotation. </td></tr>
    <tr><td class="paramname">phi</td><td><b>in</b> polar angle of the rotation. </td></tr>
    <tr><td class="paramname">theta</td><td><b>in</b> azimuthal angle of the rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 17 2014 21:31:38 for FronTier++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
